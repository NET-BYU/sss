{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Seven Segment Sign The Seven Segment Sign, or SSS for short, is a purely Python, Raspberry Pi-powered system that drives a screen of 1152 seven segment digits (arranged in a 48 x 24 array). But don't let these low specs fool you! This platform provides a beginner-friendly opportunity for anyone to learn how to address complex design problems with strict limitations. Some of the initial demos we've been able to make work are: Video Player Arcade Games and even Doom! What next? Even though the physical SSS resides in the BYU NET Lab , the source code, blueprints, and a simulator are all available on GitHub and this wiki! Take a look at the following links to help you get started: Get started Support Happy hacking!","title":"Welcome to the Seven Segment Sign"},{"location":"#welcome-to-the-seven-segment-sign","text":"The Seven Segment Sign, or SSS for short, is a purely Python, Raspberry Pi-powered system that drives a screen of 1152 seven segment digits (arranged in a 48 x 24 array). But don't let these low specs fool you! This platform provides a beginner-friendly opportunity for anyone to learn how to address complex design problems with strict limitations. Some of the initial demos we've been able to make work are:","title":"Welcome to the Seven Segment Sign"},{"location":"#video-player","text":"","title":"Video Player"},{"location":"#arcade-games","text":"","title":"Arcade Games"},{"location":"#and-even-doom","text":"","title":"and even Doom!"},{"location":"#what-next","text":"Even though the physical SSS resides in the BYU NET Lab , the source code, blueprints, and a simulator are all available on GitHub and this wiki! Take a look at the following links to help you get started: Get started Support Happy hacking!","title":"What next?"},{"location":"Release%20Notes/","text":"","title":"Release Notes"},{"location":"API/Broadcasters/","text":"Broadcasters MQTT Broadcaster start_processing_output ( system_queue , mqtt_q ) Called by the broadcaster module to initialize a connection to the desired MQTT broker. Source code in broadcasters/mqtt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def start_processing_output ( system_queue , mqtt_q ): \"\"\"Called by the broadcaster module to initialize a connection to the desired MQTT broker.\"\"\" def on_connect ( client , userdata , flags , rc ): \"\"\"Callback function executed upon the successful connection to the desired broker\"\"\" logger . info ( \"MQTT Client connected ( {} )\" , rc ) def on_disconnect ( client , userdata , rc ): \"\"\"Callback function executed upon disconnecting from the broker\"\"\" logger . info ( \"MQTT Client disconnected ( {} )\" , rc ) with open ( \"mqtt_config.yaml\" ) as f : config = safe_load ( f ) if not config [ \"host\" ] or not config [ \"port\" ]: raise ValueError ( \"mqtt_config.yaml not set up\" ) client = mqtt . Client () client . username_pw_set ( config [ \"username\" ], config [ \"password\" ]) if config [ \"tls\" ]: client . tls_set () client . on_connect = on_connect client . on_disconnect = on_disconnect def process (): \"\"\"Contains generator which fetches all messages from the `byu_sss/output` topic on broker\"\"\" while True : try : client . connect ( config [ \"host\" ], config [ \"port\" ]) while True : client . loop ( timeout = 0.01 ) for item in utils . get_all_from_queue ( mqtt_q ): client . publish ( \"byu_sss/output\" , payload = str ( item ), ) yield except ConnectionRefusedError : logger . warning ( \"Unable to connect to broker... trying again later.\" ) for _ in range ( 100 ): yield continue return process () get_all_from_queue ( queue ) Helper function that gets all items from a given queue. Source code in broadcasters/utils.py 1 2 3 4 def get_all_from_queue ( queue ): \"\"\"Helper function that gets all items from a given queue.\"\"\" while not queue . empty (): yield queue . get ()","title":"Broadcasters"},{"location":"API/Broadcasters/#broadcasters","text":"","title":"Broadcasters"},{"location":"API/Broadcasters/#mqtt-broadcaster","text":"","title":"MQTT Broadcaster"},{"location":"API/Broadcasters/#broadcasters.mqtt.start_processing_output","text":"Called by the broadcaster module to initialize a connection to the desired MQTT broker. Source code in broadcasters/mqtt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def start_processing_output ( system_queue , mqtt_q ): \"\"\"Called by the broadcaster module to initialize a connection to the desired MQTT broker.\"\"\" def on_connect ( client , userdata , flags , rc ): \"\"\"Callback function executed upon the successful connection to the desired broker\"\"\" logger . info ( \"MQTT Client connected ( {} )\" , rc ) def on_disconnect ( client , userdata , rc ): \"\"\"Callback function executed upon disconnecting from the broker\"\"\" logger . info ( \"MQTT Client disconnected ( {} )\" , rc ) with open ( \"mqtt_config.yaml\" ) as f : config = safe_load ( f ) if not config [ \"host\" ] or not config [ \"port\" ]: raise ValueError ( \"mqtt_config.yaml not set up\" ) client = mqtt . Client () client . username_pw_set ( config [ \"username\" ], config [ \"password\" ]) if config [ \"tls\" ]: client . tls_set () client . on_connect = on_connect client . on_disconnect = on_disconnect def process (): \"\"\"Contains generator which fetches all messages from the `byu_sss/output` topic on broker\"\"\" while True : try : client . connect ( config [ \"host\" ], config [ \"port\" ]) while True : client . loop ( timeout = 0.01 ) for item in utils . get_all_from_queue ( mqtt_q ): client . publish ( \"byu_sss/output\" , payload = str ( item ), ) yield except ConnectionRefusedError : logger . warning ( \"Unable to connect to broker... trying again later.\" ) for _ in range ( 100 ): yield continue return process ()","title":"start_processing_output()"},{"location":"API/Broadcasters/#broadcasters.utils.get_all_from_queue","text":"Helper function that gets all items from a given queue. Source code in broadcasters/utils.py 1 2 3 4 def get_all_from_queue ( queue ): \"\"\"Helper function that gets all items from a given queue.\"\"\" while not queue . empty (): yield queue . get ()","title":"get_all_from_queue()"},{"location":"API/Controllers/","text":"Controllers","title":"Controllers"},{"location":"API/Controllers/#controllers","text":"","title":"Controllers"},{"location":"API/Display/","text":"Display Display Game Display is a class that abstracts different S^3 panels into one display Source code in display/display.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 class Display : \"\"\"Game Display is a class that abstracts different S^3 panels into one display\"\"\" def __init__ ( self , board_objects , x_width , y_height ): \"\"\"Constructor board_objects -- 2d array of seven segment objects oriented how the sign is put together, i.e. [[panel0, panel1],[panel2,panel3]] x_width -- number of digits in the display on the x axis y_height -- number of pixels on the y axis (each vertical digit is split into two pixels) \"\"\" self . board_objects = board_objects self . x_width = int ( x_width ) self . y_height = int ( y_height ) self . display_buf = [ [ 0 for x in range ( self . x_width )] for y in range ( self . y_height // 2 ) ] self . changed_list = [] def draw_raw ( self , x , y , value , push = False ): \"\"\"Draw to a specific segment on the screen x -- x coordinate y -- y coordinate value -- which leds to turn on for the segment push -- when true all the recent changes are pushed to the display \"\"\" self . display_buf [ y ][ x ] = value self . changed_list . append (( x , y )) if push : self . push () def get_raw ( self , x , y ): \"\"\"Get the value of the segment x -- x coordinate y -- y coordinate \"\"\" return self . display_buf [ y ][ x ] def draw_pixel ( self , x , y , value , combine = True , push = False ): \"\"\"Draw shape to one pixel location x -- x coordinate y -- y coordinate value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" half_height = y // 2 if value == 0 and combine : current_value = self . display_buf [ half_height ][ x ] if y % 2 : if current_value & 0x62 : self . display_buf [ half_height ][ x ] = current_value & 0x63 else : self . display_buf [ half_height ][ x ] = current_value & 0x62 else : if current_value & 0x1C : self . display_buf [ half_height ][ x ] = current_value & 0x1D else : self . display_buf [ half_height ][ x ] = current_value & 0x1C self . changed_list . append (( x , y // 2 )) return if y % 2 : value = ( ( value & 1 ) << 3 | ( value & 2 ) << 1 | ( value & 4 ) >> 2 | ( value & 8 ) << 1 ) else : value = ( value & 3 ) | ( value & 4 ) << 4 | ( value & 8 ) << 2 # if value | self.display_buf[half_height][x] == self.display_buf[half_height][x]: # return if combine : value = self . display_buf [ half_height ][ x ] | value self . display_buf [ half_height ][ x ] = value self . changed_list . append (( x , y // 2 )) if push : self . push () def get_pixel ( self , x , y ): \"\"\"Get the value already at the pixel x -- x coordinate y -- y coordinate \"\"\" half_height = y // 2 value = self . display_buf [ half_height ][ x ] if y % 2 : half_value = ( bool ( value & 16 ) << 3 | bool ( value & 1 ) << 2 | bool ( value & 4 ) << 1 | bool ( value & 8 ) ) else : half_value = ( bool ( value & 32 ) << 3 | bool ( value & 64 ) << 2 | bool ( value & 2 ) << 1 | bool ( value & 1 ) ) return half_value def push ( self ): \"\"\"Push all the recent changes to the display\"\"\" for location in self . changed_list : self . board_objects [ location [ 1 ] // 6 ][ location [ 0 ] // 16 ] . raw2 ( location [ 0 ] % 16 , location [ 1 ] % 6 , self . display_buf [ location [ 1 ]][ location [ 0 ]], ) for row in self . board_objects : for board in row : board . flush () self . changed_list . clear () def clear ( self ): \"\"\"Clear all the panels on the display\"\"\" self . display_buf = [ [ 0 for x in range ( self . x_width )] for y in range ( self . y_height // 2 ) ] for row in self . board_objects : for board in row : board . clear () self . changed_list . clear () def draw_hline ( self , start_x , start_y , length , top = True , combine = True , push = False ): \"\"\"Draw horizontal line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw top -- draw horizontal line on the top or bottom of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" half_height = start_y // 2 if start_y % 2 : for x in range ( length ): if top : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x01 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x01 else : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x08 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x08 self . changed_list . append (( x + start_x , half_height )) else : for x in range ( length ): if top : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x40 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x40 else : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x01 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x01 self . changed_list . append (( x + start_x , half_height )) if push : self . push () def draw_vline ( self , start_x , start_y , length , left = True , combine = True , push = False ): \"\"\"Draw vertical line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw left -- draw vertial line on the left or right of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" for y in range ( length ): y_loc = start_y + y y_half = y_loc // 2 if y_loc % 2 : if left : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x04 ) else : self . display_buf [ y_half ][ start_x ] = 0x04 else : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x10 ) else : self . display_buf [ y_half ][ start_x ] = 0x10 else : if left : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x02 ) else : self . display_buf [ y_half ][ start_x ] = 0x02 else : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x20 ) else : self . display_buf [ y_half ][ start_x ] = 0x20 self . changed_list . append (( start_x , y_half )) if push : self . push () def draw_shape_line ( self , start_x , start_y , end_x , end_y , value , combine = True , push = False ): \"\"\"Draw line with given value at each pixel, can be diagonal start_x -- starting x coordinate start_y -- starting y coordinate end_x -- ending x coordinate end_y -- ending y coordiante value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" if start_x != end_x : slope = ( end_y - start_y ) / ( end_x - start_x ) b = start_y - slope * start_x for x in range ( min ( start_x , end_x ), max ( start_x , end_x ) + 1 ): self . draw_pixel ( x , round ( b ) + round ( slope * x ), value , combine ) else : for y in range ( min ( start_y , end_y ), max ( start_y , end_y ) + 1 ): self . draw_pixel ( start_x , y , value , combine ) if push : self . push () def draw_text ( self , x , y , msg , combine = True , push = False ): \"\"\"Print a message to the screen, y_height-2 is lowest y value accepted without error x -- x coordinate y -- y coordinate msg -- string message to print combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" if y % 2 : for pos , char in enumerate ( msg ): value = symbols . get_char2 ( char ) # get top and bottom values out of value top_value = ( value & 0x20 ) >> 2 | ( value & 0x40 ) >> 4 | ( value & 0x02 ) bottom_value = ( ( value & 0x04 ) >> 1 | ( value & 0x08 ) >> 3 | ( value & 0x10 ) >> 1 | ( value & 0x01 ) << 2 ) self . draw_pixel ( x + pos , y , top_value , combine = combine ) self . draw_pixel ( x + pos , y + 1 , bottom_value , combine = combine ) else : half_y = y // 2 for pos , char in enumerate ( msg ): value = symbols . get_char2 ( char ) self . display_buf [ half_y ][ x + pos ] = value self . changed_list . append (( x + pos , half_y )) if push : self . push () # work in progress def fill_box ( self , start_x , start_y , x_len , y_len , push = False ): if push : self . push () __init__ ( board_objects , x_width , y_height ) Constructor board_objects -- 2d array of seven segment objects oriented how the sign is put together, i.e. [[panel0, panel1],[panel2,panel3]] x_width -- number of digits in the display on the x axis y_height -- number of pixels on the y axis (each vertical digit is split into two pixels) Source code in display/display.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def __init__ ( self , board_objects , x_width , y_height ): \"\"\"Constructor board_objects -- 2d array of seven segment objects oriented how the sign is put together, i.e. [[panel0, panel1],[panel2,panel3]] x_width -- number of digits in the display on the x axis y_height -- number of pixels on the y axis (each vertical digit is split into two pixels) \"\"\" self . board_objects = board_objects self . x_width = int ( x_width ) self . y_height = int ( y_height ) self . display_buf = [ [ 0 for x in range ( self . x_width )] for y in range ( self . y_height // 2 ) ] self . changed_list = [] clear () Clear all the panels on the display Source code in display/display.py 125 126 127 128 129 130 131 132 133 def clear ( self ): \"\"\"Clear all the panels on the display\"\"\" self . display_buf = [ [ 0 for x in range ( self . x_width )] for y in range ( self . y_height // 2 ) ] for row in self . board_objects : for board in row : board . clear () self . changed_list . clear () draw_hline ( start_x , start_y , length , top = True , combine = True , push = False ) Draw horizontal line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw top -- draw horizontal line on the top or bottom of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display Source code in display/display.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def draw_hline ( self , start_x , start_y , length , top = True , combine = True , push = False ): \"\"\"Draw horizontal line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw top -- draw horizontal line on the top or bottom of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" half_height = start_y // 2 if start_y % 2 : for x in range ( length ): if top : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x01 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x01 else : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x08 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x08 self . changed_list . append (( x + start_x , half_height )) else : for x in range ( length ): if top : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x40 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x40 else : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x01 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x01 self . changed_list . append (( x + start_x , half_height )) if push : self . push () draw_pixel ( x , y , value , combine = True , push = False ) Draw shape to one pixel location x -- x coordinate y -- y coordinate value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display Source code in display/display.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def draw_pixel ( self , x , y , value , combine = True , push = False ): \"\"\"Draw shape to one pixel location x -- x coordinate y -- y coordinate value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" half_height = y // 2 if value == 0 and combine : current_value = self . display_buf [ half_height ][ x ] if y % 2 : if current_value & 0x62 : self . display_buf [ half_height ][ x ] = current_value & 0x63 else : self . display_buf [ half_height ][ x ] = current_value & 0x62 else : if current_value & 0x1C : self . display_buf [ half_height ][ x ] = current_value & 0x1D else : self . display_buf [ half_height ][ x ] = current_value & 0x1C self . changed_list . append (( x , y // 2 )) return if y % 2 : value = ( ( value & 1 ) << 3 | ( value & 2 ) << 1 | ( value & 4 ) >> 2 | ( value & 8 ) << 1 ) else : value = ( value & 3 ) | ( value & 4 ) << 4 | ( value & 8 ) << 2 # if value | self.display_buf[half_height][x] == self.display_buf[half_height][x]: # return if combine : value = self . display_buf [ half_height ][ x ] | value self . display_buf [ half_height ][ x ] = value self . changed_list . append (( x , y // 2 )) if push : self . push () draw_raw ( x , y , value , push = False ) Draw to a specific segment on the screen x -- x coordinate y -- y coordinate value -- which leds to turn on for the segment push -- when true all the recent changes are pushed to the display Source code in display/display.py 22 23 24 25 26 27 28 29 30 31 32 33 def draw_raw ( self , x , y , value , push = False ): \"\"\"Draw to a specific segment on the screen x -- x coordinate y -- y coordinate value -- which leds to turn on for the segment push -- when true all the recent changes are pushed to the display \"\"\" self . display_buf [ y ][ x ] = value self . changed_list . append (( x , y )) if push : self . push () draw_shape_line ( start_x , start_y , end_x , end_y , value , combine = True , push = False ) Draw line with given value at each pixel, can be diagonal start_x -- starting x coordinate start_y -- starting y coordinate end_x -- ending x coordinate end_y -- ending y coordiante value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display Source code in display/display.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def draw_shape_line ( self , start_x , start_y , end_x , end_y , value , combine = True , push = False ): \"\"\"Draw line with given value at each pixel, can be diagonal start_x -- starting x coordinate start_y -- starting y coordinate end_x -- ending x coordinate end_y -- ending y coordiante value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" if start_x != end_x : slope = ( end_y - start_y ) / ( end_x - start_x ) b = start_y - slope * start_x for x in range ( min ( start_x , end_x ), max ( start_x , end_x ) + 1 ): self . draw_pixel ( x , round ( b ) + round ( slope * x ), value , combine ) else : for y in range ( min ( start_y , end_y ), max ( start_y , end_y ) + 1 ): self . draw_pixel ( start_x , y , value , combine ) if push : self . push () draw_text ( x , y , msg , combine = True , push = False ) Print a message to the screen, y_height-2 is lowest y value accepted without error x -- x coordinate y -- y coordinate msg -- string message to print combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display Source code in display/display.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def draw_text ( self , x , y , msg , combine = True , push = False ): \"\"\"Print a message to the screen, y_height-2 is lowest y value accepted without error x -- x coordinate y -- y coordinate msg -- string message to print combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" if y % 2 : for pos , char in enumerate ( msg ): value = symbols . get_char2 ( char ) # get top and bottom values out of value top_value = ( value & 0x20 ) >> 2 | ( value & 0x40 ) >> 4 | ( value & 0x02 ) bottom_value = ( ( value & 0x04 ) >> 1 | ( value & 0x08 ) >> 3 | ( value & 0x10 ) >> 1 | ( value & 0x01 ) << 2 ) self . draw_pixel ( x + pos , y , top_value , combine = combine ) self . draw_pixel ( x + pos , y + 1 , bottom_value , combine = combine ) else : half_y = y // 2 for pos , char in enumerate ( msg ): value = symbols . get_char2 ( char ) self . display_buf [ half_y ][ x + pos ] = value self . changed_list . append (( x + pos , half_y )) if push : self . push () draw_vline ( start_x , start_y , length , left = True , combine = True , push = False ) Draw vertical line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw left -- draw vertial line on the left or right of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display Source code in display/display.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def draw_vline ( self , start_x , start_y , length , left = True , combine = True , push = False ): \"\"\"Draw vertical line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw left -- draw vertial line on the left or right of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" for y in range ( length ): y_loc = start_y + y y_half = y_loc // 2 if y_loc % 2 : if left : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x04 ) else : self . display_buf [ y_half ][ start_x ] = 0x04 else : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x10 ) else : self . display_buf [ y_half ][ start_x ] = 0x10 else : if left : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x02 ) else : self . display_buf [ y_half ][ start_x ] = 0x02 else : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x20 ) else : self . display_buf [ y_half ][ start_x ] = 0x20 self . changed_list . append (( start_x , y_half )) if push : self . push () get_pixel ( x , y ) Get the value already at the pixel x -- x coordinate y -- y coordinate Source code in display/display.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def get_pixel ( self , x , y ): \"\"\"Get the value already at the pixel x -- x coordinate y -- y coordinate \"\"\" half_height = y // 2 value = self . display_buf [ half_height ][ x ] if y % 2 : half_value = ( bool ( value & 16 ) << 3 | bool ( value & 1 ) << 2 | bool ( value & 4 ) << 1 | bool ( value & 8 ) ) else : half_value = ( bool ( value & 32 ) << 3 | bool ( value & 64 ) << 2 | bool ( value & 2 ) << 1 | bool ( value & 1 ) ) return half_value get_raw ( x , y ) Get the value of the segment x -- x coordinate y -- y coordinate Source code in display/display.py 35 36 37 38 39 40 41 def get_raw ( self , x , y ): \"\"\"Get the value of the segment x -- x coordinate y -- y coordinate \"\"\" return self . display_buf [ y ][ x ] push () Push all the recent changes to the display Source code in display/display.py 112 113 114 115 116 117 118 119 120 121 122 123 def push ( self ): \"\"\"Push all the recent changes to the display\"\"\" for location in self . changed_list : self . board_objects [ location [ 1 ] // 6 ][ location [ 0 ] // 16 ] . raw2 ( location [ 0 ] % 16 , location [ 1 ] % 6 , self . display_buf [ location [ 1 ]][ location [ 0 ]], ) for row in self . board_objects : for board in row : board . flush () self . changed_list . clear () SegmentDisplay SegmentDisplay is a class that abstracts the S^3 screen into individually controllable segments. Instead of making each circle of a segment a pixel, this class lets you control each segment as a pixel. This means this display is 2 times wider (there are two horizontal segments) and 3 times higher (there are three vertical segments) than the Display object. Source code in display/segment_display.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class SegmentDisplay : \"\"\" SegmentDisplay is a class that abstracts the S^3 screen into individually controllable segments. Instead of making each circle of a segment a pixel, this class lets you control each segment as a pixel. This means this display is 2 times wider (there are two horizontal segments) and 3 times higher (there are three vertical segments) than the Display object. \"\"\" def __init__ ( self , screen ): self . screen = screen self . screen_width = screen . x_width - 1 self . screen_height = screen . y_height // 2 self . width = 2 * self . screen_width self . height = 3 * self . screen_height self . x_buffer = np . zeros (( self . width , self . height )) self . y_buffer = np . zeros (( self . width , self . height )) def draw ( self , push = True ): \"\"\" Updates the screen with all of the lines drawn using draw_line. push -- when true all the recent changes are pushed to the display \"\"\" for x in range ( self . screen_width ): for y in range ( self . screen_height ): state = 0 if self . x_buffer [ x * 2 ][ y * 3 ]: state += 64 # 64 = TOP if self . x_buffer [ x * 2 ][ y * 3 + 1 ]: state += 1 # 1 = CENTER if self . x_buffer [ x * 2 ][ y * 3 + 2 ]: state += 8 # 8 = BOTTOM if self . y_buffer [ x * 2 + 1 ][ y * 3 ]: state += 32 # 32 = TR if self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ]: state += 16 # 16 = BR if self . y_buffer [ x * 2 ][ y * 3 + 1 ]: state += 4 # 4 = BL if self . y_buffer [ x * 2 ][ y * 3 ]: state += 2 # 2 = TL # Only draw the pixel if there is something to draw if state != 0 : self . screen . draw_raw ( x , y , state ) if push : self . screen . push () def undraw ( self ): \"\"\" Clears all segments drawn both from the screen and from the underlying data structure. \"\"\" for x in range ( self . screen_width ): for y in range ( self . screen_height ): if self . x_buffer [ x * 2 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 64 ) self . x_buffer [ x * 2 ][ y * 3 ] = False if self . x_buffer [ x * 2 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 1 ) self . x_buffer [ x * 2 ][ y * 3 + 1 ] = False if self . x_buffer [ x * 2 ][ y * 3 + 2 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 8 ) self . x_buffer [ x * 2 ][ y * 3 + 2 ] = False if self . y_buffer [ x * 2 + 1 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 32 ) self . y_buffer [ x * 2 + 1 ][ y * 3 ] = False if self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 16 ) self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ] = False if self . y_buffer [ x * 2 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 4 ) self . y_buffer [ x * 2 ][ y * 3 + 1 ] = False if self . y_buffer [ x * 2 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 2 ) self . y_buffer [ x * 2 ][ y * 3 ] = False def draw_line ( self , start_x , start_y , end_x , end_y ): \"\"\" Draws a line from coordinate to another. To display the line, you must use the draw function. This function only updates the underlying data buffer. start_x -- the starting x point start_y -- the starting y point end_x -- the ending x point end_y -- the ending y point \"\"\" start_x = self . _constrain ( start_x , 0 , self . width - 1 ) start_y = self . _constrain ( start_y , 0 , self . height - 1 ) end_x = self . _constrain ( end_x , 0 , self . width - 1 ) end_y = self . _constrain ( end_y , 0 , self . height - 1 ) if end_x < start_x : start_x , end_x = end_x , start_x start_y , end_y = end_y , start_y dx = end_x - start_x dy = end_y - start_y r = 0 ny = 0 pny = 0 nny = 0 p = dy / dx if dx != 0 else 0 t = 0 for i in range ( dx + 1 ): r = int ( round ( t )) pny = ny ny = start_y + r if i > 0 : # vertical lines connecting horizontal lines for j in range ( abs ( ny - pny )): if pny > ny : nny = pny - j - 1 else : nny = pny + j self . y_buffer [ start_x + i ][ nny ] = 1 if i != dx : self . x_buffer [ start_x + i ][ ny ] = 1 t += p if dx == 0 and dy != 0 : # in case of no vertical lines fs = 0 fe = int ( dy ) if dy < 0 : fs = fe fe = 0 for i in range ( fs , fe ): self . y_buffer [ start_x ][ start_y + i ] = 1 def _constrain ( self , val , min_val , max_val ): \"\"\"A helper function that constrains a value between two values\"\"\" return min ( max_val , max ( min_val , val )) draw ( push = True ) Updates the screen with all of the lines drawn using draw_line. push -- when true all the recent changes are pushed to the display Source code in display/segment_display.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def draw ( self , push = True ): \"\"\" Updates the screen with all of the lines drawn using draw_line. push -- when true all the recent changes are pushed to the display \"\"\" for x in range ( self . screen_width ): for y in range ( self . screen_height ): state = 0 if self . x_buffer [ x * 2 ][ y * 3 ]: state += 64 # 64 = TOP if self . x_buffer [ x * 2 ][ y * 3 + 1 ]: state += 1 # 1 = CENTER if self . x_buffer [ x * 2 ][ y * 3 + 2 ]: state += 8 # 8 = BOTTOM if self . y_buffer [ x * 2 + 1 ][ y * 3 ]: state += 32 # 32 = TR if self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ]: state += 16 # 16 = BR if self . y_buffer [ x * 2 ][ y * 3 + 1 ]: state += 4 # 4 = BL if self . y_buffer [ x * 2 ][ y * 3 ]: state += 2 # 2 = TL # Only draw the pixel if there is something to draw if state != 0 : self . screen . draw_raw ( x , y , state ) if push : self . screen . push () draw_line ( start_x , start_y , end_x , end_y ) Draws a line from coordinate to another. To display the line, you must use the draw function. This function only updates the underlying data buffer. start_x -- the starting x point start_y -- the starting y point end_x -- the ending x point end_y -- the ending y point Source code in display/segment_display.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def draw_line ( self , start_x , start_y , end_x , end_y ): \"\"\" Draws a line from coordinate to another. To display the line, you must use the draw function. This function only updates the underlying data buffer. start_x -- the starting x point start_y -- the starting y point end_x -- the ending x point end_y -- the ending y point \"\"\" start_x = self . _constrain ( start_x , 0 , self . width - 1 ) start_y = self . _constrain ( start_y , 0 , self . height - 1 ) end_x = self . _constrain ( end_x , 0 , self . width - 1 ) end_y = self . _constrain ( end_y , 0 , self . height - 1 ) if end_x < start_x : start_x , end_x = end_x , start_x start_y , end_y = end_y , start_y dx = end_x - start_x dy = end_y - start_y r = 0 ny = 0 pny = 0 nny = 0 p = dy / dx if dx != 0 else 0 t = 0 for i in range ( dx + 1 ): r = int ( round ( t )) pny = ny ny = start_y + r if i > 0 : # vertical lines connecting horizontal lines for j in range ( abs ( ny - pny )): if pny > ny : nny = pny - j - 1 else : nny = pny + j self . y_buffer [ start_x + i ][ nny ] = 1 if i != dx : self . x_buffer [ start_x + i ][ ny ] = 1 t += p if dx == 0 and dy != 0 : # in case of no vertical lines fs = 0 fe = int ( dy ) if dy < 0 : fs = fe fe = 0 for i in range ( fs , fe ): self . y_buffer [ start_x ][ start_y + i ] = 1 undraw () Clears all segments drawn both from the screen and from the underlying data structure. Source code in display/segment_display.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def undraw ( self ): \"\"\" Clears all segments drawn both from the screen and from the underlying data structure. \"\"\" for x in range ( self . screen_width ): for y in range ( self . screen_height ): if self . x_buffer [ x * 2 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 64 ) self . x_buffer [ x * 2 ][ y * 3 ] = False if self . x_buffer [ x * 2 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 1 ) self . x_buffer [ x * 2 ][ y * 3 + 1 ] = False if self . x_buffer [ x * 2 ][ y * 3 + 2 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 8 ) self . x_buffer [ x * 2 ][ y * 3 + 2 ] = False if self . y_buffer [ x * 2 + 1 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 32 ) self . y_buffer [ x * 2 + 1 ][ y * 3 ] = False if self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 16 ) self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ] = False if self . y_buffer [ x * 2 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 4 ) self . y_buffer [ x * 2 ][ y * 3 + 1 ] = False if self . y_buffer [ x * 2 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 2 ) self . y_buffer [ x * 2 ][ y * 3 ] = False SevenSegment Source code in display/seven_seg.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class SevenSegment : def __init__ ( self , num_digits = 8 , num_per_segment = MAX7219_DIGITS , baudrate = DEFAULT_BAUDRATE , cs_num = 0 , brightness = 7 , clear = True , segment_orientation_array = None , ): \"\"\"Constructor num_digits -- total number of digits in your display (default 8) num_per_segment -- total number of digits per MAX7219 segment (default 8) baudrate -- rate at which data is transfered (default 9000kHz), excessive rate may result in instability cs_num -- which control select line is being used (default 0) brightness -- starting brightness of the leds (default 7) clear -- clear the screen on initialization (default True) segment_orientation_array -- a 2d array of where the MAX7219 segments are located, one indexed (default None) : example [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] (height is 6 and width is 16) : this needs to be populated to use coordinate grid style functions i.e. letter2 (default None) \"\"\" self . num_digits = num_digits self . num_segments = num_digits // num_per_segment self . num_per_segment = num_per_segment self . baudrate = baudrate if baudrate < 10000000 else 10000000 self . _buf = [ 0 ] * self . num_digits self . _display_buf = [ 0 ] * self . num_digits self . _spi = spidev . SpiDev () self . _spi . open ( 0 , cs_num ) self . _spi . max_speed_hz = self . baudrate # Setup the display self . command ( MAX7219_REG_SHUTDOWN , 1 ) # 1 enables the display self . command ( MAX7219_REG_DECODEMODE , 0 ) # 0x01, 0x0F, 0xFF for different Code B modes self . command ( MAX7219_REG_SCANLIMIT , self . num_per_segment - 1 ) self . command ( MAX7219_REG_DISPLAYTEST , 0 ) self . brightness ( brightness ) # Set up cascaded segemtn orientation stuff to enable 2 functions self . display = ( None or segment_orientation_array ) # [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] self . _display_y_len = len ( self . display ) if self . display is not None else None self . _flush_index = [] if clear : self . clear () def command ( self , register_num , value ): \"\"\"Sets control registers for each segment in the display\"\"\" # check register_num is good if register_num not in [ MAX7219_REG_DECODEMODE , MAX7219_REG_INTENSITY , MAX7219_REG_SCANLIMIT , MAX7219_REG_SHUTDOWN , MAX7219_REG_DISPLAYTEST , ]: raise ValueError ( \"register_num is not a correct value\" ) # check value is good if not isinstance ( value , ( int )) or ( value > 16 or value < 0 ): raise ValueError ( \"value is not a correct value\" ) self . _write ([ register_num , value ] * self . num_segments ) def close ( self , clear = True , shutdown = True ): \"\"\"Close the spi connection\"\"\" if clear : self . clear () if shutdown : self . command ( MAX7219_REG_SHUTDOWN , 0 ) self . _spi . close () def clear ( self , flush = True ): \"\"\"Clears the buffer, and if specified, flushes the display\"\"\" self . _buf = [ 0 ] * self . num_digits if flush : self . flush_legacy () def brightness ( self , value ): \"\"\"Sets the brightness for all of the segments ranging from 0 - 15\"\"\" # check value is good if not isinstance ( value , ( int )) or ( value > 16 or value < 0 ): raise ValueError ( \"value is not a correct value\" ) self . command ( MAX7219_REG_INTENSITY , value ) # Original flush, about 2 times slower than the current flush function, used in clear def flush_legacy ( self ): \"\"\"Cascade the buffer onto the display\"\"\" for seg in range ( self . num_segments ): for pos in range ( self . num_per_segment ): self . _write ( ([ MAX7219_REG_NOOP , 0 ] * ( self . num_segments - seg )) + [ pos + MAX7219_REG_DIGIT0 , self . _buf [ pos + ( seg * self . num_per_segment )], ] + ([ MAX7219_REG_NOOP , 0 ] * seg ) ) def flush ( self ): \"\"\"Flush all the current changes to the display\"\"\" for pos in self . _flush_index : self . _write ( [ MAX7219_REG_NOOP , 0 ] * ( self . num_segments - 1 - int ( pos / self . num_per_segment )) + [ MAX7219_REG_DIGIT0 + pos % self . num_per_segment , self . _buf [ pos ]] + [ MAX7219_REG_NOOP , 0 ] * int ( pos / self . num_per_segment ) ) self . _flush_index . clear () def raw ( self , position , value , flush = False ): \"\"\"Given raw 0-255 value draw symbol at given postion\"\"\" # Check if position is valid if ( not isinstance ( position , ( int )) or position < 0 or position >= self . num_digits ): raise ValueError ( \"position is not a valid number\" ) # Check if char is int between 0 and 255 if not isinstance ( value , ( int )) or value < 0 or value > 255 : raise ValueError ( \"value is either not an int or out of bounds (0-255)\" ) self . _buf [ position ] = value self . _flush_index . append ( position ) if flush : self . flush () def raw2 ( self , x , y , value , flush = False ): \"\"\"Given raw 0-255 value draw symbol at given coordinate\"\"\" position = self . _get_pos ( x , y ) self . raw ( position , value , flush ) def letter ( self , position , char , dot = False , flush = False ): \"\"\"Outputs ascii letter as close as it can, working letters/symbols found in symbols.py\"\"\" # Check if position is valid if ( not isinstance ( position , ( int )) or position < 0 or position >= self . num_digits ): raise ValueError ( \"position is not a valid number\" ) value = sy . get_char2 ( char ) | ( dot << 7 ) self . _buf [ position ] = value self . _flush_index . append ( position ) if flush : self . flush () def letter2 ( self , x , y , char , dot = False , flush = False ): \"\"\"Output letter on the display at the coordinates provided if possible\"\"\" # Check to make sure segment array has been initialized if self . display is None : raise ValueError ( \"segment_orientation_array has not been initialized\" ) pos = self . _get_pos ( x , y ) self . letter ( pos , char , dot , flush ) def text ( self , txt , start_position = 0 , flush = False ): \"\"\"Output text on the display at the start position if possible\"\"\" # Check if txt is going to overflow buffer if start_position + len ( txt . replace ( \".\" , \"\" )) > self . num_digits : raise OverflowError ( \"Message would overflow spi buffer\" ) for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter ( pos + start_position - 1 , txt [ pos - 1 ], dot = True ) else : self . letter ( start_position + pos , char ) if flush : self . flush () def text2 ( self , x , y , txt , horizontal = True , flush = False ): \"\"\"Output text on the display at the given x, y - option to display horizontal or vertical text\"\"\" # No initial checks and will let underlying functions do the work if horizontal : # self.text(txt, self._get_pos(x, y)) for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter2 ( x + pos - 1 , y , txt [ pos - 1 ], True ) else : self . letter2 ( x + pos , y , char ) else : for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter2 ( x , y + pos - 1 , txt [ pos - 1 ], True ) else : self . letter2 ( x , y + pos , char ) if flush : self . flush () # Write to the SPI file through SPI library def _write ( self , data ): self . _spi . writebytes ( bytes ( data )) # Get position in the buffer for a given x,y coordinate def _get_pos ( self , x , y ): # Check y is within bounds if not isinstance ( y , ( int )) or y < 0 or y >= self . _display_y_len : return ValueError ( \"y value is not a valid number\" ) # Check if x is an int if not isinstance ( x , ( int )): return ValueError ( \"x value is not an integer\" ) x_seg = int ( x / self . num_per_segment ) # check if x is within bounds of y row if x_seg >= len ( self . display [ y ]): raise ValueError ( \"x value is out of range\" ) return ( self . display [ y ][ x_seg ] - 1 ) * self . num_per_segment + ( x % self . num_per_segment ) # Not current in use def _check_buf ( self ): indices = [] for pos in range ( len ( self . _buf )): if self . _buf [ pos ] != self . _display_buf [ pos ]: indices . append ( pos ) return indices __init__ ( num_digits = 8 , num_per_segment = MAX7219_DIGITS , baudrate = DEFAULT_BAUDRATE , cs_num = 0 , brightness = 7 , clear = True , segment_orientation_array = None ) Constructor num_digits -- total number of digits in your display (default 8) num_per_segment -- total number of digits per MAX7219 segment (default 8) baudrate -- rate at which data is transfered (default 9000kHz), excessive rate may result in instability cs_num -- which control select line is being used (default 0) brightness -- starting brightness of the leds (default 7) clear -- clear the screen on initialization (default True) segment_orientation_array -- a 2d array of where the MAX7219 segments are located, one indexed (default None) : example [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] (height is 6 and width is 16) : this needs to be populated to use coordinate grid style functions i.e. letter2 (default None) Source code in display/seven_seg.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , num_digits = 8 , num_per_segment = MAX7219_DIGITS , baudrate = DEFAULT_BAUDRATE , cs_num = 0 , brightness = 7 , clear = True , segment_orientation_array = None , ): \"\"\"Constructor num_digits -- total number of digits in your display (default 8) num_per_segment -- total number of digits per MAX7219 segment (default 8) baudrate -- rate at which data is transfered (default 9000kHz), excessive rate may result in instability cs_num -- which control select line is being used (default 0) brightness -- starting brightness of the leds (default 7) clear -- clear the screen on initialization (default True) segment_orientation_array -- a 2d array of where the MAX7219 segments are located, one indexed (default None) : example [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] (height is 6 and width is 16) : this needs to be populated to use coordinate grid style functions i.e. letter2 (default None) \"\"\" self . num_digits = num_digits self . num_segments = num_digits // num_per_segment self . num_per_segment = num_per_segment self . baudrate = baudrate if baudrate < 10000000 else 10000000 self . _buf = [ 0 ] * self . num_digits self . _display_buf = [ 0 ] * self . num_digits self . _spi = spidev . SpiDev () self . _spi . open ( 0 , cs_num ) self . _spi . max_speed_hz = self . baudrate # Setup the display self . command ( MAX7219_REG_SHUTDOWN , 1 ) # 1 enables the display self . command ( MAX7219_REG_DECODEMODE , 0 ) # 0x01, 0x0F, 0xFF for different Code B modes self . command ( MAX7219_REG_SCANLIMIT , self . num_per_segment - 1 ) self . command ( MAX7219_REG_DISPLAYTEST , 0 ) self . brightness ( brightness ) # Set up cascaded segemtn orientation stuff to enable 2 functions self . display = ( None or segment_orientation_array ) # [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] self . _display_y_len = len ( self . display ) if self . display is not None else None self . _flush_index = [] if clear : self . clear () brightness ( value ) Sets the brightness for all of the segments ranging from 0 - 15 Source code in display/seven_seg.py 115 116 117 118 119 120 def brightness ( self , value ): \"\"\"Sets the brightness for all of the segments ranging from 0 - 15\"\"\" # check value is good if not isinstance ( value , ( int )) or ( value > 16 or value < 0 ): raise ValueError ( \"value is not a correct value\" ) self . command ( MAX7219_REG_INTENSITY , value ) clear ( flush = True ) Clears the buffer, and if specified, flushes the display Source code in display/seven_seg.py 109 110 111 112 113 def clear ( self , flush = True ): \"\"\"Clears the buffer, and if specified, flushes the display\"\"\" self . _buf = [ 0 ] * self . num_digits if flush : self . flush_legacy () close ( clear = True , shutdown = True ) Close the spi connection Source code in display/seven_seg.py 101 102 103 104 105 106 107 def close ( self , clear = True , shutdown = True ): \"\"\"Close the spi connection\"\"\" if clear : self . clear () if shutdown : self . command ( MAX7219_REG_SHUTDOWN , 0 ) self . _spi . close () command ( register_num , value ) Sets control registers for each segment in the display Source code in display/seven_seg.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def command ( self , register_num , value ): \"\"\"Sets control registers for each segment in the display\"\"\" # check register_num is good if register_num not in [ MAX7219_REG_DECODEMODE , MAX7219_REG_INTENSITY , MAX7219_REG_SCANLIMIT , MAX7219_REG_SHUTDOWN , MAX7219_REG_DISPLAYTEST , ]: raise ValueError ( \"register_num is not a correct value\" ) # check value is good if not isinstance ( value , ( int )) or ( value > 16 or value < 0 ): raise ValueError ( \"value is not a correct value\" ) self . _write ([ register_num , value ] * self . num_segments ) flush () Flush all the current changes to the display Source code in display/seven_seg.py 136 137 138 139 140 141 142 143 144 145 def flush ( self ): \"\"\"Flush all the current changes to the display\"\"\" for pos in self . _flush_index : self . _write ( [ MAX7219_REG_NOOP , 0 ] * ( self . num_segments - 1 - int ( pos / self . num_per_segment )) + [ MAX7219_REG_DIGIT0 + pos % self . num_per_segment , self . _buf [ pos ]] + [ MAX7219_REG_NOOP , 0 ] * int ( pos / self . num_per_segment ) ) self . _flush_index . clear () flush_legacy () Cascade the buffer onto the display Source code in display/seven_seg.py 123 124 125 126 127 128 129 130 131 132 133 134 def flush_legacy ( self ): \"\"\"Cascade the buffer onto the display\"\"\" for seg in range ( self . num_segments ): for pos in range ( self . num_per_segment ): self . _write ( ([ MAX7219_REG_NOOP , 0 ] * ( self . num_segments - seg )) + [ pos + MAX7219_REG_DIGIT0 , self . _buf [ pos + ( seg * self . num_per_segment )], ] + ([ MAX7219_REG_NOOP , 0 ] * seg ) ) letter ( position , char , dot = False , flush = False ) Outputs ascii letter as close as it can, working letters/symbols found in symbols.py Source code in display/seven_seg.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def letter ( self , position , char , dot = False , flush = False ): \"\"\"Outputs ascii letter as close as it can, working letters/symbols found in symbols.py\"\"\" # Check if position is valid if ( not isinstance ( position , ( int )) or position < 0 or position >= self . num_digits ): raise ValueError ( \"position is not a valid number\" ) value = sy . get_char2 ( char ) | ( dot << 7 ) self . _buf [ position ] = value self . _flush_index . append ( position ) if flush : self . flush () letter2 ( x , y , char , dot = False , flush = False ) Output letter on the display at the coordinates provided if possible Source code in display/seven_seg.py 185 186 187 188 189 190 191 def letter2 ( self , x , y , char , dot = False , flush = False ): \"\"\"Output letter on the display at the coordinates provided if possible\"\"\" # Check to make sure segment array has been initialized if self . display is None : raise ValueError ( \"segment_orientation_array has not been initialized\" ) pos = self . _get_pos ( x , y ) self . letter ( pos , char , dot , flush ) raw ( position , value , flush = False ) Given raw 0-255 value draw symbol at given postion Source code in display/seven_seg.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def raw ( self , position , value , flush = False ): \"\"\"Given raw 0-255 value draw symbol at given postion\"\"\" # Check if position is valid if ( not isinstance ( position , ( int )) or position < 0 or position >= self . num_digits ): raise ValueError ( \"position is not a valid number\" ) # Check if char is int between 0 and 255 if not isinstance ( value , ( int )) or value < 0 or value > 255 : raise ValueError ( \"value is either not an int or out of bounds (0-255)\" ) self . _buf [ position ] = value self . _flush_index . append ( position ) if flush : self . flush () raw2 ( x , y , value , flush = False ) Given raw 0-255 value draw symbol at given coordinate Source code in display/seven_seg.py 165 166 167 168 def raw2 ( self , x , y , value , flush = False ): \"\"\"Given raw 0-255 value draw symbol at given coordinate\"\"\" position = self . _get_pos ( x , y ) self . raw ( position , value , flush ) text ( txt , start_position = 0 , flush = False ) Output text on the display at the start position if possible Source code in display/seven_seg.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def text ( self , txt , start_position = 0 , flush = False ): \"\"\"Output text on the display at the start position if possible\"\"\" # Check if txt is going to overflow buffer if start_position + len ( txt . replace ( \".\" , \"\" )) > self . num_digits : raise OverflowError ( \"Message would overflow spi buffer\" ) for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter ( pos + start_position - 1 , txt [ pos - 1 ], dot = True ) else : self . letter ( start_position + pos , char ) if flush : self . flush () text2 ( x , y , txt , horizontal = True , flush = False ) Output text on the display at the given x, y - option to display horizontal or vertical text Source code in display/seven_seg.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def text2 ( self , x , y , txt , horizontal = True , flush = False ): \"\"\"Output text on the display at the given x, y - option to display horizontal or vertical text\"\"\" # No initial checks and will let underlying functions do the work if horizontal : # self.text(txt, self._get_pos(x, y)) for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter2 ( x + pos - 1 , y , txt [ pos - 1 ], True ) else : self . letter2 ( x + pos , y , char ) else : for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter2 ( x , y + pos - 1 , txt [ pos - 1 ], True ) else : self . letter2 ( x , y + pos , char ) if flush : self . flush ()","title":"Display"},{"location":"API/Display/#display","text":"","title":"Display"},{"location":"API/Display/#display.display.Display","text":"Game Display is a class that abstracts different S^3 panels into one display Source code in display/display.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 class Display : \"\"\"Game Display is a class that abstracts different S^3 panels into one display\"\"\" def __init__ ( self , board_objects , x_width , y_height ): \"\"\"Constructor board_objects -- 2d array of seven segment objects oriented how the sign is put together, i.e. [[panel0, panel1],[panel2,panel3]] x_width -- number of digits in the display on the x axis y_height -- number of pixels on the y axis (each vertical digit is split into two pixels) \"\"\" self . board_objects = board_objects self . x_width = int ( x_width ) self . y_height = int ( y_height ) self . display_buf = [ [ 0 for x in range ( self . x_width )] for y in range ( self . y_height // 2 ) ] self . changed_list = [] def draw_raw ( self , x , y , value , push = False ): \"\"\"Draw to a specific segment on the screen x -- x coordinate y -- y coordinate value -- which leds to turn on for the segment push -- when true all the recent changes are pushed to the display \"\"\" self . display_buf [ y ][ x ] = value self . changed_list . append (( x , y )) if push : self . push () def get_raw ( self , x , y ): \"\"\"Get the value of the segment x -- x coordinate y -- y coordinate \"\"\" return self . display_buf [ y ][ x ] def draw_pixel ( self , x , y , value , combine = True , push = False ): \"\"\"Draw shape to one pixel location x -- x coordinate y -- y coordinate value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" half_height = y // 2 if value == 0 and combine : current_value = self . display_buf [ half_height ][ x ] if y % 2 : if current_value & 0x62 : self . display_buf [ half_height ][ x ] = current_value & 0x63 else : self . display_buf [ half_height ][ x ] = current_value & 0x62 else : if current_value & 0x1C : self . display_buf [ half_height ][ x ] = current_value & 0x1D else : self . display_buf [ half_height ][ x ] = current_value & 0x1C self . changed_list . append (( x , y // 2 )) return if y % 2 : value = ( ( value & 1 ) << 3 | ( value & 2 ) << 1 | ( value & 4 ) >> 2 | ( value & 8 ) << 1 ) else : value = ( value & 3 ) | ( value & 4 ) << 4 | ( value & 8 ) << 2 # if value | self.display_buf[half_height][x] == self.display_buf[half_height][x]: # return if combine : value = self . display_buf [ half_height ][ x ] | value self . display_buf [ half_height ][ x ] = value self . changed_list . append (( x , y // 2 )) if push : self . push () def get_pixel ( self , x , y ): \"\"\"Get the value already at the pixel x -- x coordinate y -- y coordinate \"\"\" half_height = y // 2 value = self . display_buf [ half_height ][ x ] if y % 2 : half_value = ( bool ( value & 16 ) << 3 | bool ( value & 1 ) << 2 | bool ( value & 4 ) << 1 | bool ( value & 8 ) ) else : half_value = ( bool ( value & 32 ) << 3 | bool ( value & 64 ) << 2 | bool ( value & 2 ) << 1 | bool ( value & 1 ) ) return half_value def push ( self ): \"\"\"Push all the recent changes to the display\"\"\" for location in self . changed_list : self . board_objects [ location [ 1 ] // 6 ][ location [ 0 ] // 16 ] . raw2 ( location [ 0 ] % 16 , location [ 1 ] % 6 , self . display_buf [ location [ 1 ]][ location [ 0 ]], ) for row in self . board_objects : for board in row : board . flush () self . changed_list . clear () def clear ( self ): \"\"\"Clear all the panels on the display\"\"\" self . display_buf = [ [ 0 for x in range ( self . x_width )] for y in range ( self . y_height // 2 ) ] for row in self . board_objects : for board in row : board . clear () self . changed_list . clear () def draw_hline ( self , start_x , start_y , length , top = True , combine = True , push = False ): \"\"\"Draw horizontal line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw top -- draw horizontal line on the top or bottom of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" half_height = start_y // 2 if start_y % 2 : for x in range ( length ): if top : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x01 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x01 else : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x08 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x08 self . changed_list . append (( x + start_x , half_height )) else : for x in range ( length ): if top : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x40 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x40 else : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x01 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x01 self . changed_list . append (( x + start_x , half_height )) if push : self . push () def draw_vline ( self , start_x , start_y , length , left = True , combine = True , push = False ): \"\"\"Draw vertical line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw left -- draw vertial line on the left or right of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" for y in range ( length ): y_loc = start_y + y y_half = y_loc // 2 if y_loc % 2 : if left : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x04 ) else : self . display_buf [ y_half ][ start_x ] = 0x04 else : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x10 ) else : self . display_buf [ y_half ][ start_x ] = 0x10 else : if left : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x02 ) else : self . display_buf [ y_half ][ start_x ] = 0x02 else : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x20 ) else : self . display_buf [ y_half ][ start_x ] = 0x20 self . changed_list . append (( start_x , y_half )) if push : self . push () def draw_shape_line ( self , start_x , start_y , end_x , end_y , value , combine = True , push = False ): \"\"\"Draw line with given value at each pixel, can be diagonal start_x -- starting x coordinate start_y -- starting y coordinate end_x -- ending x coordinate end_y -- ending y coordiante value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" if start_x != end_x : slope = ( end_y - start_y ) / ( end_x - start_x ) b = start_y - slope * start_x for x in range ( min ( start_x , end_x ), max ( start_x , end_x ) + 1 ): self . draw_pixel ( x , round ( b ) + round ( slope * x ), value , combine ) else : for y in range ( min ( start_y , end_y ), max ( start_y , end_y ) + 1 ): self . draw_pixel ( start_x , y , value , combine ) if push : self . push () def draw_text ( self , x , y , msg , combine = True , push = False ): \"\"\"Print a message to the screen, y_height-2 is lowest y value accepted without error x -- x coordinate y -- y coordinate msg -- string message to print combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" if y % 2 : for pos , char in enumerate ( msg ): value = symbols . get_char2 ( char ) # get top and bottom values out of value top_value = ( value & 0x20 ) >> 2 | ( value & 0x40 ) >> 4 | ( value & 0x02 ) bottom_value = ( ( value & 0x04 ) >> 1 | ( value & 0x08 ) >> 3 | ( value & 0x10 ) >> 1 | ( value & 0x01 ) << 2 ) self . draw_pixel ( x + pos , y , top_value , combine = combine ) self . draw_pixel ( x + pos , y + 1 , bottom_value , combine = combine ) else : half_y = y // 2 for pos , char in enumerate ( msg ): value = symbols . get_char2 ( char ) self . display_buf [ half_y ][ x + pos ] = value self . changed_list . append (( x + pos , half_y )) if push : self . push () # work in progress def fill_box ( self , start_x , start_y , x_len , y_len , push = False ): if push : self . push ()","title":"Display"},{"location":"API/Display/#display.display.Display.__init__","text":"Constructor board_objects -- 2d array of seven segment objects oriented how the sign is put together, i.e. [[panel0, panel1],[panel2,panel3]] x_width -- number of digits in the display on the x axis y_height -- number of pixels on the y axis (each vertical digit is split into two pixels) Source code in display/display.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def __init__ ( self , board_objects , x_width , y_height ): \"\"\"Constructor board_objects -- 2d array of seven segment objects oriented how the sign is put together, i.e. [[panel0, panel1],[panel2,panel3]] x_width -- number of digits in the display on the x axis y_height -- number of pixels on the y axis (each vertical digit is split into two pixels) \"\"\" self . board_objects = board_objects self . x_width = int ( x_width ) self . y_height = int ( y_height ) self . display_buf = [ [ 0 for x in range ( self . x_width )] for y in range ( self . y_height // 2 ) ] self . changed_list = []","title":"__init__()"},{"location":"API/Display/#display.display.Display.clear","text":"Clear all the panels on the display Source code in display/display.py 125 126 127 128 129 130 131 132 133 def clear ( self ): \"\"\"Clear all the panels on the display\"\"\" self . display_buf = [ [ 0 for x in range ( self . x_width )] for y in range ( self . y_height // 2 ) ] for row in self . board_objects : for board in row : board . clear () self . changed_list . clear ()","title":"clear()"},{"location":"API/Display/#display.display.Display.draw_hline","text":"Draw horizontal line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw top -- draw horizontal line on the top or bottom of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display Source code in display/display.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def draw_hline ( self , start_x , start_y , length , top = True , combine = True , push = False ): \"\"\"Draw horizontal line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw top -- draw horizontal line on the top or bottom of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" half_height = start_y // 2 if start_y % 2 : for x in range ( length ): if top : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x01 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x01 else : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x08 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x08 self . changed_list . append (( x + start_x , half_height )) else : for x in range ( length ): if top : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x40 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x40 else : if combine : self . display_buf [ half_height ][ x + start_x ] = ( self . display_buf [ half_height ][ x + start_x ] | 0x01 ) else : self . display_buf [ half_height ][ x + start_x ] = 0x01 self . changed_list . append (( x + start_x , half_height )) if push : self . push ()","title":"draw_hline()"},{"location":"API/Display/#display.display.Display.draw_pixel","text":"Draw shape to one pixel location x -- x coordinate y -- y coordinate value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display Source code in display/display.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def draw_pixel ( self , x , y , value , combine = True , push = False ): \"\"\"Draw shape to one pixel location x -- x coordinate y -- y coordinate value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" half_height = y // 2 if value == 0 and combine : current_value = self . display_buf [ half_height ][ x ] if y % 2 : if current_value & 0x62 : self . display_buf [ half_height ][ x ] = current_value & 0x63 else : self . display_buf [ half_height ][ x ] = current_value & 0x62 else : if current_value & 0x1C : self . display_buf [ half_height ][ x ] = current_value & 0x1D else : self . display_buf [ half_height ][ x ] = current_value & 0x1C self . changed_list . append (( x , y // 2 )) return if y % 2 : value = ( ( value & 1 ) << 3 | ( value & 2 ) << 1 | ( value & 4 ) >> 2 | ( value & 8 ) << 1 ) else : value = ( value & 3 ) | ( value & 4 ) << 4 | ( value & 8 ) << 2 # if value | self.display_buf[half_height][x] == self.display_buf[half_height][x]: # return if combine : value = self . display_buf [ half_height ][ x ] | value self . display_buf [ half_height ][ x ] = value self . changed_list . append (( x , y // 2 )) if push : self . push ()","title":"draw_pixel()"},{"location":"API/Display/#display.display.Display.draw_raw","text":"Draw to a specific segment on the screen x -- x coordinate y -- y coordinate value -- which leds to turn on for the segment push -- when true all the recent changes are pushed to the display Source code in display/display.py 22 23 24 25 26 27 28 29 30 31 32 33 def draw_raw ( self , x , y , value , push = False ): \"\"\"Draw to a specific segment on the screen x -- x coordinate y -- y coordinate value -- which leds to turn on for the segment push -- when true all the recent changes are pushed to the display \"\"\" self . display_buf [ y ][ x ] = value self . changed_list . append (( x , y )) if push : self . push ()","title":"draw_raw()"},{"location":"API/Display/#display.display.Display.draw_shape_line","text":"Draw line with given value at each pixel, can be diagonal start_x -- starting x coordinate start_y -- starting y coordinate end_x -- ending x coordinate end_y -- ending y coordiante value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display Source code in display/display.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def draw_shape_line ( self , start_x , start_y , end_x , end_y , value , combine = True , push = False ): \"\"\"Draw line with given value at each pixel, can be diagonal start_x -- starting x coordinate start_y -- starting y coordinate end_x -- ending x coordinate end_y -- ending y coordiante value -- which leds to turn on for the pixel (1 for bottom, 2 for left, 4 for top, 8 for right, add sides together for multiple sides) combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" if start_x != end_x : slope = ( end_y - start_y ) / ( end_x - start_x ) b = start_y - slope * start_x for x in range ( min ( start_x , end_x ), max ( start_x , end_x ) + 1 ): self . draw_pixel ( x , round ( b ) + round ( slope * x ), value , combine ) else : for y in range ( min ( start_y , end_y ), max ( start_y , end_y ) + 1 ): self . draw_pixel ( start_x , y , value , combine ) if push : self . push ()","title":"draw_shape_line()"},{"location":"API/Display/#display.display.Display.draw_text","text":"Print a message to the screen, y_height-2 is lowest y value accepted without error x -- x coordinate y -- y coordinate msg -- string message to print combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display Source code in display/display.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def draw_text ( self , x , y , msg , combine = True , push = False ): \"\"\"Print a message to the screen, y_height-2 is lowest y value accepted without error x -- x coordinate y -- y coordinate msg -- string message to print combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" if y % 2 : for pos , char in enumerate ( msg ): value = symbols . get_char2 ( char ) # get top and bottom values out of value top_value = ( value & 0x20 ) >> 2 | ( value & 0x40 ) >> 4 | ( value & 0x02 ) bottom_value = ( ( value & 0x04 ) >> 1 | ( value & 0x08 ) >> 3 | ( value & 0x10 ) >> 1 | ( value & 0x01 ) << 2 ) self . draw_pixel ( x + pos , y , top_value , combine = combine ) self . draw_pixel ( x + pos , y + 1 , bottom_value , combine = combine ) else : half_y = y // 2 for pos , char in enumerate ( msg ): value = symbols . get_char2 ( char ) self . display_buf [ half_y ][ x + pos ] = value self . changed_list . append (( x + pos , half_y )) if push : self . push ()","title":"draw_text()"},{"location":"API/Display/#display.display.Display.draw_vline","text":"Draw vertical line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw left -- draw vertial line on the left or right of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display Source code in display/display.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def draw_vline ( self , start_x , start_y , length , left = True , combine = True , push = False ): \"\"\"Draw vertical line start_x -- x coordinate start_y -- y coordinate length -- length of line to draw left -- draw vertial line on the left or right of the pixel combine -- digits are split into two pixels, when drawing to one combine keeps what is already drawn on the other side of the digit push -- when true all the recent changes are pushed to the display \"\"\" for y in range ( length ): y_loc = start_y + y y_half = y_loc // 2 if y_loc % 2 : if left : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x04 ) else : self . display_buf [ y_half ][ start_x ] = 0x04 else : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x10 ) else : self . display_buf [ y_half ][ start_x ] = 0x10 else : if left : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x02 ) else : self . display_buf [ y_half ][ start_x ] = 0x02 else : if combine : self . display_buf [ y_half ][ start_x ] = ( self . display_buf [ y_half ][ start_x ] | 0x20 ) else : self . display_buf [ y_half ][ start_x ] = 0x20 self . changed_list . append (( start_x , y_half )) if push : self . push ()","title":"draw_vline()"},{"location":"API/Display/#display.display.Display.get_pixel","text":"Get the value already at the pixel x -- x coordinate y -- y coordinate Source code in display/display.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def get_pixel ( self , x , y ): \"\"\"Get the value already at the pixel x -- x coordinate y -- y coordinate \"\"\" half_height = y // 2 value = self . display_buf [ half_height ][ x ] if y % 2 : half_value = ( bool ( value & 16 ) << 3 | bool ( value & 1 ) << 2 | bool ( value & 4 ) << 1 | bool ( value & 8 ) ) else : half_value = ( bool ( value & 32 ) << 3 | bool ( value & 64 ) << 2 | bool ( value & 2 ) << 1 | bool ( value & 1 ) ) return half_value","title":"get_pixel()"},{"location":"API/Display/#display.display.Display.get_raw","text":"Get the value of the segment x -- x coordinate y -- y coordinate Source code in display/display.py 35 36 37 38 39 40 41 def get_raw ( self , x , y ): \"\"\"Get the value of the segment x -- x coordinate y -- y coordinate \"\"\" return self . display_buf [ y ][ x ]","title":"get_raw()"},{"location":"API/Display/#display.display.Display.push","text":"Push all the recent changes to the display Source code in display/display.py 112 113 114 115 116 117 118 119 120 121 122 123 def push ( self ): \"\"\"Push all the recent changes to the display\"\"\" for location in self . changed_list : self . board_objects [ location [ 1 ] // 6 ][ location [ 0 ] // 16 ] . raw2 ( location [ 0 ] % 16 , location [ 1 ] % 6 , self . display_buf [ location [ 1 ]][ location [ 0 ]], ) for row in self . board_objects : for board in row : board . flush () self . changed_list . clear ()","title":"push()"},{"location":"API/Display/#display.segment_display.SegmentDisplay","text":"SegmentDisplay is a class that abstracts the S^3 screen into individually controllable segments. Instead of making each circle of a segment a pixel, this class lets you control each segment as a pixel. This means this display is 2 times wider (there are two horizontal segments) and 3 times higher (there are three vertical segments) than the Display object. Source code in display/segment_display.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class SegmentDisplay : \"\"\" SegmentDisplay is a class that abstracts the S^3 screen into individually controllable segments. Instead of making each circle of a segment a pixel, this class lets you control each segment as a pixel. This means this display is 2 times wider (there are two horizontal segments) and 3 times higher (there are three vertical segments) than the Display object. \"\"\" def __init__ ( self , screen ): self . screen = screen self . screen_width = screen . x_width - 1 self . screen_height = screen . y_height // 2 self . width = 2 * self . screen_width self . height = 3 * self . screen_height self . x_buffer = np . zeros (( self . width , self . height )) self . y_buffer = np . zeros (( self . width , self . height )) def draw ( self , push = True ): \"\"\" Updates the screen with all of the lines drawn using draw_line. push -- when true all the recent changes are pushed to the display \"\"\" for x in range ( self . screen_width ): for y in range ( self . screen_height ): state = 0 if self . x_buffer [ x * 2 ][ y * 3 ]: state += 64 # 64 = TOP if self . x_buffer [ x * 2 ][ y * 3 + 1 ]: state += 1 # 1 = CENTER if self . x_buffer [ x * 2 ][ y * 3 + 2 ]: state += 8 # 8 = BOTTOM if self . y_buffer [ x * 2 + 1 ][ y * 3 ]: state += 32 # 32 = TR if self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ]: state += 16 # 16 = BR if self . y_buffer [ x * 2 ][ y * 3 + 1 ]: state += 4 # 4 = BL if self . y_buffer [ x * 2 ][ y * 3 ]: state += 2 # 2 = TL # Only draw the pixel if there is something to draw if state != 0 : self . screen . draw_raw ( x , y , state ) if push : self . screen . push () def undraw ( self ): \"\"\" Clears all segments drawn both from the screen and from the underlying data structure. \"\"\" for x in range ( self . screen_width ): for y in range ( self . screen_height ): if self . x_buffer [ x * 2 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 64 ) self . x_buffer [ x * 2 ][ y * 3 ] = False if self . x_buffer [ x * 2 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 1 ) self . x_buffer [ x * 2 ][ y * 3 + 1 ] = False if self . x_buffer [ x * 2 ][ y * 3 + 2 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 8 ) self . x_buffer [ x * 2 ][ y * 3 + 2 ] = False if self . y_buffer [ x * 2 + 1 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 32 ) self . y_buffer [ x * 2 + 1 ][ y * 3 ] = False if self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 16 ) self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ] = False if self . y_buffer [ x * 2 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 4 ) self . y_buffer [ x * 2 ][ y * 3 + 1 ] = False if self . y_buffer [ x * 2 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 2 ) self . y_buffer [ x * 2 ][ y * 3 ] = False def draw_line ( self , start_x , start_y , end_x , end_y ): \"\"\" Draws a line from coordinate to another. To display the line, you must use the draw function. This function only updates the underlying data buffer. start_x -- the starting x point start_y -- the starting y point end_x -- the ending x point end_y -- the ending y point \"\"\" start_x = self . _constrain ( start_x , 0 , self . width - 1 ) start_y = self . _constrain ( start_y , 0 , self . height - 1 ) end_x = self . _constrain ( end_x , 0 , self . width - 1 ) end_y = self . _constrain ( end_y , 0 , self . height - 1 ) if end_x < start_x : start_x , end_x = end_x , start_x start_y , end_y = end_y , start_y dx = end_x - start_x dy = end_y - start_y r = 0 ny = 0 pny = 0 nny = 0 p = dy / dx if dx != 0 else 0 t = 0 for i in range ( dx + 1 ): r = int ( round ( t )) pny = ny ny = start_y + r if i > 0 : # vertical lines connecting horizontal lines for j in range ( abs ( ny - pny )): if pny > ny : nny = pny - j - 1 else : nny = pny + j self . y_buffer [ start_x + i ][ nny ] = 1 if i != dx : self . x_buffer [ start_x + i ][ ny ] = 1 t += p if dx == 0 and dy != 0 : # in case of no vertical lines fs = 0 fe = int ( dy ) if dy < 0 : fs = fe fe = 0 for i in range ( fs , fe ): self . y_buffer [ start_x ][ start_y + i ] = 1 def _constrain ( self , val , min_val , max_val ): \"\"\"A helper function that constrains a value between two values\"\"\" return min ( max_val , max ( min_val , val ))","title":"SegmentDisplay"},{"location":"API/Display/#display.segment_display.SegmentDisplay.draw","text":"Updates the screen with all of the lines drawn using draw_line. push -- when true all the recent changes are pushed to the display Source code in display/segment_display.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def draw ( self , push = True ): \"\"\" Updates the screen with all of the lines drawn using draw_line. push -- when true all the recent changes are pushed to the display \"\"\" for x in range ( self . screen_width ): for y in range ( self . screen_height ): state = 0 if self . x_buffer [ x * 2 ][ y * 3 ]: state += 64 # 64 = TOP if self . x_buffer [ x * 2 ][ y * 3 + 1 ]: state += 1 # 1 = CENTER if self . x_buffer [ x * 2 ][ y * 3 + 2 ]: state += 8 # 8 = BOTTOM if self . y_buffer [ x * 2 + 1 ][ y * 3 ]: state += 32 # 32 = TR if self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ]: state += 16 # 16 = BR if self . y_buffer [ x * 2 ][ y * 3 + 1 ]: state += 4 # 4 = BL if self . y_buffer [ x * 2 ][ y * 3 ]: state += 2 # 2 = TL # Only draw the pixel if there is something to draw if state != 0 : self . screen . draw_raw ( x , y , state ) if push : self . screen . push ()","title":"draw()"},{"location":"API/Display/#display.segment_display.SegmentDisplay.draw_line","text":"Draws a line from coordinate to another. To display the line, you must use the draw function. This function only updates the underlying data buffer. start_x -- the starting x point start_y -- the starting y point end_x -- the ending x point end_y -- the ending y point Source code in display/segment_display.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def draw_line ( self , start_x , start_y , end_x , end_y ): \"\"\" Draws a line from coordinate to another. To display the line, you must use the draw function. This function only updates the underlying data buffer. start_x -- the starting x point start_y -- the starting y point end_x -- the ending x point end_y -- the ending y point \"\"\" start_x = self . _constrain ( start_x , 0 , self . width - 1 ) start_y = self . _constrain ( start_y , 0 , self . height - 1 ) end_x = self . _constrain ( end_x , 0 , self . width - 1 ) end_y = self . _constrain ( end_y , 0 , self . height - 1 ) if end_x < start_x : start_x , end_x = end_x , start_x start_y , end_y = end_y , start_y dx = end_x - start_x dy = end_y - start_y r = 0 ny = 0 pny = 0 nny = 0 p = dy / dx if dx != 0 else 0 t = 0 for i in range ( dx + 1 ): r = int ( round ( t )) pny = ny ny = start_y + r if i > 0 : # vertical lines connecting horizontal lines for j in range ( abs ( ny - pny )): if pny > ny : nny = pny - j - 1 else : nny = pny + j self . y_buffer [ start_x + i ][ nny ] = 1 if i != dx : self . x_buffer [ start_x + i ][ ny ] = 1 t += p if dx == 0 and dy != 0 : # in case of no vertical lines fs = 0 fe = int ( dy ) if dy < 0 : fs = fe fe = 0 for i in range ( fs , fe ): self . y_buffer [ start_x ][ start_y + i ] = 1","title":"draw_line()"},{"location":"API/Display/#display.segment_display.SegmentDisplay.undraw","text":"Clears all segments drawn both from the screen and from the underlying data structure. Source code in display/segment_display.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def undraw ( self ): \"\"\" Clears all segments drawn both from the screen and from the underlying data structure. \"\"\" for x in range ( self . screen_width ): for y in range ( self . screen_height ): if self . x_buffer [ x * 2 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 64 ) self . x_buffer [ x * 2 ][ y * 3 ] = False if self . x_buffer [ x * 2 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 1 ) self . x_buffer [ x * 2 ][ y * 3 + 1 ] = False if self . x_buffer [ x * 2 ][ y * 3 + 2 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 8 ) self . x_buffer [ x * 2 ][ y * 3 + 2 ] = False if self . y_buffer [ x * 2 + 1 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 32 ) self . y_buffer [ x * 2 + 1 ][ y * 3 ] = False if self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 16 ) self . y_buffer [ x * 2 + 1 ][ y * 3 + 1 ] = False if self . y_buffer [ x * 2 ][ y * 3 + 1 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 4 ) self . y_buffer [ x * 2 ][ y * 3 + 1 ] = False if self . y_buffer [ x * 2 ][ y * 3 ]: value = self . screen . get_raw ( x , y ) self . screen . draw_raw ( x , y , value - 2 ) self . y_buffer [ x * 2 ][ y * 3 ] = False","title":"undraw()"},{"location":"API/Display/#display.seven_seg.SevenSegment","text":"Source code in display/seven_seg.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class SevenSegment : def __init__ ( self , num_digits = 8 , num_per_segment = MAX7219_DIGITS , baudrate = DEFAULT_BAUDRATE , cs_num = 0 , brightness = 7 , clear = True , segment_orientation_array = None , ): \"\"\"Constructor num_digits -- total number of digits in your display (default 8) num_per_segment -- total number of digits per MAX7219 segment (default 8) baudrate -- rate at which data is transfered (default 9000kHz), excessive rate may result in instability cs_num -- which control select line is being used (default 0) brightness -- starting brightness of the leds (default 7) clear -- clear the screen on initialization (default True) segment_orientation_array -- a 2d array of where the MAX7219 segments are located, one indexed (default None) : example [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] (height is 6 and width is 16) : this needs to be populated to use coordinate grid style functions i.e. letter2 (default None) \"\"\" self . num_digits = num_digits self . num_segments = num_digits // num_per_segment self . num_per_segment = num_per_segment self . baudrate = baudrate if baudrate < 10000000 else 10000000 self . _buf = [ 0 ] * self . num_digits self . _display_buf = [ 0 ] * self . num_digits self . _spi = spidev . SpiDev () self . _spi . open ( 0 , cs_num ) self . _spi . max_speed_hz = self . baudrate # Setup the display self . command ( MAX7219_REG_SHUTDOWN , 1 ) # 1 enables the display self . command ( MAX7219_REG_DECODEMODE , 0 ) # 0x01, 0x0F, 0xFF for different Code B modes self . command ( MAX7219_REG_SCANLIMIT , self . num_per_segment - 1 ) self . command ( MAX7219_REG_DISPLAYTEST , 0 ) self . brightness ( brightness ) # Set up cascaded segemtn orientation stuff to enable 2 functions self . display = ( None or segment_orientation_array ) # [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] self . _display_y_len = len ( self . display ) if self . display is not None else None self . _flush_index = [] if clear : self . clear () def command ( self , register_num , value ): \"\"\"Sets control registers for each segment in the display\"\"\" # check register_num is good if register_num not in [ MAX7219_REG_DECODEMODE , MAX7219_REG_INTENSITY , MAX7219_REG_SCANLIMIT , MAX7219_REG_SHUTDOWN , MAX7219_REG_DISPLAYTEST , ]: raise ValueError ( \"register_num is not a correct value\" ) # check value is good if not isinstance ( value , ( int )) or ( value > 16 or value < 0 ): raise ValueError ( \"value is not a correct value\" ) self . _write ([ register_num , value ] * self . num_segments ) def close ( self , clear = True , shutdown = True ): \"\"\"Close the spi connection\"\"\" if clear : self . clear () if shutdown : self . command ( MAX7219_REG_SHUTDOWN , 0 ) self . _spi . close () def clear ( self , flush = True ): \"\"\"Clears the buffer, and if specified, flushes the display\"\"\" self . _buf = [ 0 ] * self . num_digits if flush : self . flush_legacy () def brightness ( self , value ): \"\"\"Sets the brightness for all of the segments ranging from 0 - 15\"\"\" # check value is good if not isinstance ( value , ( int )) or ( value > 16 or value < 0 ): raise ValueError ( \"value is not a correct value\" ) self . command ( MAX7219_REG_INTENSITY , value ) # Original flush, about 2 times slower than the current flush function, used in clear def flush_legacy ( self ): \"\"\"Cascade the buffer onto the display\"\"\" for seg in range ( self . num_segments ): for pos in range ( self . num_per_segment ): self . _write ( ([ MAX7219_REG_NOOP , 0 ] * ( self . num_segments - seg )) + [ pos + MAX7219_REG_DIGIT0 , self . _buf [ pos + ( seg * self . num_per_segment )], ] + ([ MAX7219_REG_NOOP , 0 ] * seg ) ) def flush ( self ): \"\"\"Flush all the current changes to the display\"\"\" for pos in self . _flush_index : self . _write ( [ MAX7219_REG_NOOP , 0 ] * ( self . num_segments - 1 - int ( pos / self . num_per_segment )) + [ MAX7219_REG_DIGIT0 + pos % self . num_per_segment , self . _buf [ pos ]] + [ MAX7219_REG_NOOP , 0 ] * int ( pos / self . num_per_segment ) ) self . _flush_index . clear () def raw ( self , position , value , flush = False ): \"\"\"Given raw 0-255 value draw symbol at given postion\"\"\" # Check if position is valid if ( not isinstance ( position , ( int )) or position < 0 or position >= self . num_digits ): raise ValueError ( \"position is not a valid number\" ) # Check if char is int between 0 and 255 if not isinstance ( value , ( int )) or value < 0 or value > 255 : raise ValueError ( \"value is either not an int or out of bounds (0-255)\" ) self . _buf [ position ] = value self . _flush_index . append ( position ) if flush : self . flush () def raw2 ( self , x , y , value , flush = False ): \"\"\"Given raw 0-255 value draw symbol at given coordinate\"\"\" position = self . _get_pos ( x , y ) self . raw ( position , value , flush ) def letter ( self , position , char , dot = False , flush = False ): \"\"\"Outputs ascii letter as close as it can, working letters/symbols found in symbols.py\"\"\" # Check if position is valid if ( not isinstance ( position , ( int )) or position < 0 or position >= self . num_digits ): raise ValueError ( \"position is not a valid number\" ) value = sy . get_char2 ( char ) | ( dot << 7 ) self . _buf [ position ] = value self . _flush_index . append ( position ) if flush : self . flush () def letter2 ( self , x , y , char , dot = False , flush = False ): \"\"\"Output letter on the display at the coordinates provided if possible\"\"\" # Check to make sure segment array has been initialized if self . display is None : raise ValueError ( \"segment_orientation_array has not been initialized\" ) pos = self . _get_pos ( x , y ) self . letter ( pos , char , dot , flush ) def text ( self , txt , start_position = 0 , flush = False ): \"\"\"Output text on the display at the start position if possible\"\"\" # Check if txt is going to overflow buffer if start_position + len ( txt . replace ( \".\" , \"\" )) > self . num_digits : raise OverflowError ( \"Message would overflow spi buffer\" ) for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter ( pos + start_position - 1 , txt [ pos - 1 ], dot = True ) else : self . letter ( start_position + pos , char ) if flush : self . flush () def text2 ( self , x , y , txt , horizontal = True , flush = False ): \"\"\"Output text on the display at the given x, y - option to display horizontal or vertical text\"\"\" # No initial checks and will let underlying functions do the work if horizontal : # self.text(txt, self._get_pos(x, y)) for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter2 ( x + pos - 1 , y , txt [ pos - 1 ], True ) else : self . letter2 ( x + pos , y , char ) else : for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter2 ( x , y + pos - 1 , txt [ pos - 1 ], True ) else : self . letter2 ( x , y + pos , char ) if flush : self . flush () # Write to the SPI file through SPI library def _write ( self , data ): self . _spi . writebytes ( bytes ( data )) # Get position in the buffer for a given x,y coordinate def _get_pos ( self , x , y ): # Check y is within bounds if not isinstance ( y , ( int )) or y < 0 or y >= self . _display_y_len : return ValueError ( \"y value is not a valid number\" ) # Check if x is an int if not isinstance ( x , ( int )): return ValueError ( \"x value is not an integer\" ) x_seg = int ( x / self . num_per_segment ) # check if x is within bounds of y row if x_seg >= len ( self . display [ y ]): raise ValueError ( \"x value is out of range\" ) return ( self . display [ y ][ x_seg ] - 1 ) * self . num_per_segment + ( x % self . num_per_segment ) # Not current in use def _check_buf ( self ): indices = [] for pos in range ( len ( self . _buf )): if self . _buf [ pos ] != self . _display_buf [ pos ]: indices . append ( pos ) return indices","title":"SevenSegment"},{"location":"API/Display/#display.seven_seg.SevenSegment.__init__","text":"Constructor num_digits -- total number of digits in your display (default 8) num_per_segment -- total number of digits per MAX7219 segment (default 8) baudrate -- rate at which data is transfered (default 9000kHz), excessive rate may result in instability cs_num -- which control select line is being used (default 0) brightness -- starting brightness of the leds (default 7) clear -- clear the screen on initialization (default True) segment_orientation_array -- a 2d array of where the MAX7219 segments are located, one indexed (default None) : example [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] (height is 6 and width is 16) : this needs to be populated to use coordinate grid style functions i.e. letter2 (default None) Source code in display/seven_seg.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , num_digits = 8 , num_per_segment = MAX7219_DIGITS , baudrate = DEFAULT_BAUDRATE , cs_num = 0 , brightness = 7 , clear = True , segment_orientation_array = None , ): \"\"\"Constructor num_digits -- total number of digits in your display (default 8) num_per_segment -- total number of digits per MAX7219 segment (default 8) baudrate -- rate at which data is transfered (default 9000kHz), excessive rate may result in instability cs_num -- which control select line is being used (default 0) brightness -- starting brightness of the leds (default 7) clear -- clear the screen on initialization (default True) segment_orientation_array -- a 2d array of where the MAX7219 segments are located, one indexed (default None) : example [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] (height is 6 and width is 16) : this needs to be populated to use coordinate grid style functions i.e. letter2 (default None) \"\"\" self . num_digits = num_digits self . num_segments = num_digits // num_per_segment self . num_per_segment = num_per_segment self . baudrate = baudrate if baudrate < 10000000 else 10000000 self . _buf = [ 0 ] * self . num_digits self . _display_buf = [ 0 ] * self . num_digits self . _spi = spidev . SpiDev () self . _spi . open ( 0 , cs_num ) self . _spi . max_speed_hz = self . baudrate # Setup the display self . command ( MAX7219_REG_SHUTDOWN , 1 ) # 1 enables the display self . command ( MAX7219_REG_DECODEMODE , 0 ) # 0x01, 0x0F, 0xFF for different Code B modes self . command ( MAX7219_REG_SCANLIMIT , self . num_per_segment - 1 ) self . command ( MAX7219_REG_DISPLAYTEST , 0 ) self . brightness ( brightness ) # Set up cascaded segemtn orientation stuff to enable 2 functions self . display = ( None or segment_orientation_array ) # [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] self . _display_y_len = len ( self . display ) if self . display is not None else None self . _flush_index = [] if clear : self . clear ()","title":"__init__()"},{"location":"API/Display/#display.seven_seg.SevenSegment.brightness","text":"Sets the brightness for all of the segments ranging from 0 - 15 Source code in display/seven_seg.py 115 116 117 118 119 120 def brightness ( self , value ): \"\"\"Sets the brightness for all of the segments ranging from 0 - 15\"\"\" # check value is good if not isinstance ( value , ( int )) or ( value > 16 or value < 0 ): raise ValueError ( \"value is not a correct value\" ) self . command ( MAX7219_REG_INTENSITY , value )","title":"brightness()"},{"location":"API/Display/#display.seven_seg.SevenSegment.clear","text":"Clears the buffer, and if specified, flushes the display Source code in display/seven_seg.py 109 110 111 112 113 def clear ( self , flush = True ): \"\"\"Clears the buffer, and if specified, flushes the display\"\"\" self . _buf = [ 0 ] * self . num_digits if flush : self . flush_legacy ()","title":"clear()"},{"location":"API/Display/#display.seven_seg.SevenSegment.close","text":"Close the spi connection Source code in display/seven_seg.py 101 102 103 104 105 106 107 def close ( self , clear = True , shutdown = True ): \"\"\"Close the spi connection\"\"\" if clear : self . clear () if shutdown : self . command ( MAX7219_REG_SHUTDOWN , 0 ) self . _spi . close ()","title":"close()"},{"location":"API/Display/#display.seven_seg.SevenSegment.command","text":"Sets control registers for each segment in the display Source code in display/seven_seg.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def command ( self , register_num , value ): \"\"\"Sets control registers for each segment in the display\"\"\" # check register_num is good if register_num not in [ MAX7219_REG_DECODEMODE , MAX7219_REG_INTENSITY , MAX7219_REG_SCANLIMIT , MAX7219_REG_SHUTDOWN , MAX7219_REG_DISPLAYTEST , ]: raise ValueError ( \"register_num is not a correct value\" ) # check value is good if not isinstance ( value , ( int )) or ( value > 16 or value < 0 ): raise ValueError ( \"value is not a correct value\" ) self . _write ([ register_num , value ] * self . num_segments )","title":"command()"},{"location":"API/Display/#display.seven_seg.SevenSegment.flush","text":"Flush all the current changes to the display Source code in display/seven_seg.py 136 137 138 139 140 141 142 143 144 145 def flush ( self ): \"\"\"Flush all the current changes to the display\"\"\" for pos in self . _flush_index : self . _write ( [ MAX7219_REG_NOOP , 0 ] * ( self . num_segments - 1 - int ( pos / self . num_per_segment )) + [ MAX7219_REG_DIGIT0 + pos % self . num_per_segment , self . _buf [ pos ]] + [ MAX7219_REG_NOOP , 0 ] * int ( pos / self . num_per_segment ) ) self . _flush_index . clear ()","title":"flush()"},{"location":"API/Display/#display.seven_seg.SevenSegment.flush_legacy","text":"Cascade the buffer onto the display Source code in display/seven_seg.py 123 124 125 126 127 128 129 130 131 132 133 134 def flush_legacy ( self ): \"\"\"Cascade the buffer onto the display\"\"\" for seg in range ( self . num_segments ): for pos in range ( self . num_per_segment ): self . _write ( ([ MAX7219_REG_NOOP , 0 ] * ( self . num_segments - seg )) + [ pos + MAX7219_REG_DIGIT0 , self . _buf [ pos + ( seg * self . num_per_segment )], ] + ([ MAX7219_REG_NOOP , 0 ] * seg ) )","title":"flush_legacy()"},{"location":"API/Display/#display.seven_seg.SevenSegment.letter","text":"Outputs ascii letter as close as it can, working letters/symbols found in symbols.py Source code in display/seven_seg.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def letter ( self , position , char , dot = False , flush = False ): \"\"\"Outputs ascii letter as close as it can, working letters/symbols found in symbols.py\"\"\" # Check if position is valid if ( not isinstance ( position , ( int )) or position < 0 or position >= self . num_digits ): raise ValueError ( \"position is not a valid number\" ) value = sy . get_char2 ( char ) | ( dot << 7 ) self . _buf [ position ] = value self . _flush_index . append ( position ) if flush : self . flush ()","title":"letter()"},{"location":"API/Display/#display.seven_seg.SevenSegment.letter2","text":"Output letter on the display at the coordinates provided if possible Source code in display/seven_seg.py 185 186 187 188 189 190 191 def letter2 ( self , x , y , char , dot = False , flush = False ): \"\"\"Output letter on the display at the coordinates provided if possible\"\"\" # Check to make sure segment array has been initialized if self . display is None : raise ValueError ( \"segment_orientation_array has not been initialized\" ) pos = self . _get_pos ( x , y ) self . letter ( pos , char , dot , flush )","title":"letter2()"},{"location":"API/Display/#display.seven_seg.SevenSegment.raw","text":"Given raw 0-255 value draw symbol at given postion Source code in display/seven_seg.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def raw ( self , position , value , flush = False ): \"\"\"Given raw 0-255 value draw symbol at given postion\"\"\" # Check if position is valid if ( not isinstance ( position , ( int )) or position < 0 or position >= self . num_digits ): raise ValueError ( \"position is not a valid number\" ) # Check if char is int between 0 and 255 if not isinstance ( value , ( int )) or value < 0 or value > 255 : raise ValueError ( \"value is either not an int or out of bounds (0-255)\" ) self . _buf [ position ] = value self . _flush_index . append ( position ) if flush : self . flush ()","title":"raw()"},{"location":"API/Display/#display.seven_seg.SevenSegment.raw2","text":"Given raw 0-255 value draw symbol at given coordinate Source code in display/seven_seg.py 165 166 167 168 def raw2 ( self , x , y , value , flush = False ): \"\"\"Given raw 0-255 value draw symbol at given coordinate\"\"\" position = self . _get_pos ( x , y ) self . raw ( position , value , flush )","title":"raw2()"},{"location":"API/Display/#display.seven_seg.SevenSegment.text","text":"Output text on the display at the start position if possible Source code in display/seven_seg.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def text ( self , txt , start_position = 0 , flush = False ): \"\"\"Output text on the display at the start position if possible\"\"\" # Check if txt is going to overflow buffer if start_position + len ( txt . replace ( \".\" , \"\" )) > self . num_digits : raise OverflowError ( \"Message would overflow spi buffer\" ) for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter ( pos + start_position - 1 , txt [ pos - 1 ], dot = True ) else : self . letter ( start_position + pos , char ) if flush : self . flush ()","title":"text()"},{"location":"API/Display/#display.seven_seg.SevenSegment.text2","text":"Output text on the display at the given x, y - option to display horizontal or vertical text Source code in display/seven_seg.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def text2 ( self , x , y , txt , horizontal = True , flush = False ): \"\"\"Output text on the display at the given x, y - option to display horizontal or vertical text\"\"\" # No initial checks and will let underlying functions do the work if horizontal : # self.text(txt, self._get_pos(x, y)) for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter2 ( x + pos - 1 , y , txt [ pos - 1 ], True ) else : self . letter2 ( x + pos , y , char ) else : for pos , char in enumerate ( txt ): # Check if current char is a dot and append to previous letter if char == \".\" and pos != 0 : # mutliple dots in a row cause an error self . letter2 ( x , y + pos - 1 , txt [ pos - 1 ], True ) else : self . letter2 ( x , y + pos , char ) if flush : self . flush ()","title":"text2()"},{"location":"Hardware/Camera/","text":"The purpose of a camera module exists thanks mainly thanks to the creative camera demo by Bryson Schiel . While any camera which streams to an IP address will work with the demo, we have provided an inexpensive option which integrates nicely with the SSS. This module is centered around the ESP-CAM kit and it's firmware. All of these files are available in the hw/camera directory of the project. All of these files were designed and provided by Carter Pollan . Camera PCB Blueprints Backpack Schematic The ESP-CAM normally comes with its own backpack which provides power. An optional set of pins was included in the design to allow for a peripheral to connect to the camera if necessary. The backpack that we have provides power and also a breakout to connect devices to some of the GPIO pins. Backpack PCB This PCB is single-sided and has no vias which means that it can be etched on the most simple of mills. It also features some groovy, curved traces for a nice aesthetic. Check this video out to see why melty boards are superior. Camera Enclosure For those who aren't a big fan of have a jumbled mess of wires and PCBs, a sleek two piece case has also been designed to encapsulate and mount the camera module. Lid { \"imports\": { \"three\": \"../../assets/three.module.js\" } } import * as THREE from 'three'; import { OrbitControls } from '../../assets/OrbitControls.js'; import { ThreeMFLoader } from '../../assets/3MFLoader.js'; let camera, scene, renderer, object, loader, controls; var container = document.getElementById('camera-lid'); init(); function init() { renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( 500, 300 ); renderer.setClearColor( 0x000000, 0 ); // the default container.appendChild( renderer.domElement ); renderer.domElement.style.cursor = \"grab\"; scene = new THREE.Scene(); scene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) ); camera = new THREE.PerspectiveCamera( 15, window.innerWidth / window.innerHeight, 1, 500 ); // Z is up for objects intended to be 3D printed. camera.up.set( 0, 0, 1 ); camera.position.set( - 100, - 250, 100 ); scene.add( camera ); controls = new OrbitControls( camera, renderer.domElement ); controls.addEventListener( 'change', render ); controls.minDistance = 50; controls.maxDistance = 400; controls.enablePan = false; controls.update(); const pointLight = new THREE.PointLight( 0xffffff, 0.8 ); camera.add( pointLight ); const manager = new THREE.LoadingManager(); manager.onLoad = function () { const aabb = new THREE.Box3().setFromObject( object ); const center = aabb.getCenter( new THREE.Vector3() ); object.position.x += ( object.position.x - center.x ); object.position.y += ( object.position.y - center.y ); object.position.z += ( object.position.z - center.z ); controls.reset(); scene.add( object ); render(); }; loader = new ThreeMFLoader( manager ); loadAsset( '../../assets/cam-lid-sss.3mf' ); // window.addEventListener( 'resize', onWindowResize ); } function loadAsset( asset ) { loader.load( asset, function ( group ) { if ( object ) { object.traverse( function ( child ) { if ( child.material ) child.material.dispose(); if ( child.material && child.material.map ) child.material.map.dispose(); if ( child.geometry ) child.geometry.dispose(); } ); scene.remove( object ); } object = group; } ); } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); render(); } function render() { renderer.render( scene, camera ); } import * as THREE from 'three'; import { OrbitControls } from '../../assets/OrbitControls.js'; import { ThreeMFLoader } from '../../assets/3MFLoader.js'; let camera, scene, renderer, object, loader, controls; var container = document.getElementById('camera-body'); init(); function init() { renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( 500, 300 ); renderer.setClearColor( 0x000000, 0 ); // the default container.appendChild( renderer.domElement ); renderer.domElement.style.cursor = \"grab\"; scene = new THREE.Scene(); scene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) ); camera = new THREE.PerspectiveCamera( 15, window.innerWidth / window.innerHeight, 1, 500 ); // Z is up for objects intended to be 3D printed. camera.up.set( 0, 0, 1 ); camera.position.set( - 100, - 250, 100 ); scene.add( camera ); controls = new OrbitControls( camera, renderer.domElement ); controls.addEventListener( 'change', render ); controls.minDistance = 50; controls.maxDistance = 400; controls.enablePan = false; controls.update(); const pointLight = new THREE.PointLight( 0xffffff, 0.8 ); camera.add( pointLight ); const manager = new THREE.LoadingManager(); manager.onLoad = function () { const aabb = new THREE.Box3().setFromObject( object ); const center = aabb.getCenter( new THREE.Vector3() ); object.position.x += ( object.position.x - center.x ); object.position.y += ( object.position.y - center.y ); object.position.z += ( object.position.z - center.z ); controls.reset(); scene.add( object ); render(); }; loader = new ThreeMFLoader( manager ); loadAsset( '../../assets/cam-case-sss.3mf' ); // window.addEventListener( 'resize', onWindowResize ); } function loadAsset( asset ) { loader.load( asset, function ( group ) { if ( object ) { object.traverse( function ( child ) { if ( child.material ) child.material.dispose(); if ( child.material && child.material.map ) child.material.map.dispose(); if ( child.geometry ) child.geometry.dispose(); } ); scene.remove( object ); } object = group; } ); } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); render(); } function render() { renderer.render( scene, camera ); } Case","title":"Camera"},{"location":"Hardware/Camera/#camera-pcb-blueprints","text":"","title":"Camera PCB Blueprints"},{"location":"Hardware/Camera/#backpack-schematic","text":"The ESP-CAM normally comes with its own backpack which provides power. An optional set of pins was included in the design to allow for a peripheral to connect to the camera if necessary. The backpack that we have provides power and also a breakout to connect devices to some of the GPIO pins.","title":"Backpack Schematic"},{"location":"Hardware/Camera/#backpack-pcb","text":"This PCB is single-sided and has no vias which means that it can be etched on the most simple of mills. It also features some groovy, curved traces for a nice aesthetic. Check this video out to see why melty boards are superior.","title":"Backpack PCB"},{"location":"Hardware/Camera/#camera-enclosure","text":"For those who aren't a big fan of have a jumbled mess of wires and PCBs, a sleek two piece case has also been designed to encapsulate and mount the camera module.","title":"Camera Enclosure"},{"location":"Hardware/Camera/#lid","text":"{ \"imports\": { \"three\": \"../../assets/three.module.js\" } } import * as THREE from 'three'; import { OrbitControls } from '../../assets/OrbitControls.js'; import { ThreeMFLoader } from '../../assets/3MFLoader.js'; let camera, scene, renderer, object, loader, controls; var container = document.getElementById('camera-lid'); init(); function init() { renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( 500, 300 ); renderer.setClearColor( 0x000000, 0 ); // the default container.appendChild( renderer.domElement ); renderer.domElement.style.cursor = \"grab\"; scene = new THREE.Scene(); scene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) ); camera = new THREE.PerspectiveCamera( 15, window.innerWidth / window.innerHeight, 1, 500 ); // Z is up for objects intended to be 3D printed. camera.up.set( 0, 0, 1 ); camera.position.set( - 100, - 250, 100 ); scene.add( camera ); controls = new OrbitControls( camera, renderer.domElement ); controls.addEventListener( 'change', render ); controls.minDistance = 50; controls.maxDistance = 400; controls.enablePan = false; controls.update(); const pointLight = new THREE.PointLight( 0xffffff, 0.8 ); camera.add( pointLight ); const manager = new THREE.LoadingManager(); manager.onLoad = function () { const aabb = new THREE.Box3().setFromObject( object ); const center = aabb.getCenter( new THREE.Vector3() ); object.position.x += ( object.position.x - center.x ); object.position.y += ( object.position.y - center.y ); object.position.z += ( object.position.z - center.z ); controls.reset(); scene.add( object ); render(); }; loader = new ThreeMFLoader( manager ); loadAsset( '../../assets/cam-lid-sss.3mf' ); // window.addEventListener( 'resize', onWindowResize ); } function loadAsset( asset ) { loader.load( asset, function ( group ) { if ( object ) { object.traverse( function ( child ) { if ( child.material ) child.material.dispose(); if ( child.material && child.material.map ) child.material.map.dispose(); if ( child.geometry ) child.geometry.dispose(); } ); scene.remove( object ); } object = group; } ); } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); render(); } function render() { renderer.render( scene, camera ); } import * as THREE from 'three'; import { OrbitControls } from '../../assets/OrbitControls.js'; import { ThreeMFLoader } from '../../assets/3MFLoader.js'; let camera, scene, renderer, object, loader, controls; var container = document.getElementById('camera-body'); init(); function init() { renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( 500, 300 ); renderer.setClearColor( 0x000000, 0 ); // the default container.appendChild( renderer.domElement ); renderer.domElement.style.cursor = \"grab\"; scene = new THREE.Scene(); scene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) ); camera = new THREE.PerspectiveCamera( 15, window.innerWidth / window.innerHeight, 1, 500 ); // Z is up for objects intended to be 3D printed. camera.up.set( 0, 0, 1 ); camera.position.set( - 100, - 250, 100 ); scene.add( camera ); controls = new OrbitControls( camera, renderer.domElement ); controls.addEventListener( 'change', render ); controls.minDistance = 50; controls.maxDistance = 400; controls.enablePan = false; controls.update(); const pointLight = new THREE.PointLight( 0xffffff, 0.8 ); camera.add( pointLight ); const manager = new THREE.LoadingManager(); manager.onLoad = function () { const aabb = new THREE.Box3().setFromObject( object ); const center = aabb.getCenter( new THREE.Vector3() ); object.position.x += ( object.position.x - center.x ); object.position.y += ( object.position.y - center.y ); object.position.z += ( object.position.z - center.z ); controls.reset(); scene.add( object ); render(); }; loader = new ThreeMFLoader( manager ); loadAsset( '../../assets/cam-case-sss.3mf' ); // window.addEventListener( 'resize', onWindowResize ); } function loadAsset( asset ) { loader.load( asset, function ( group ) { if ( object ) { object.traverse( function ( child ) { if ( child.material ) child.material.dispose(); if ( child.material && child.material.map ) child.material.map.dispose(); if ( child.geometry ) child.geometry.dispose(); } ); scene.remove( object ); } object = group; } ); } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); render(); } function render() { renderer.render( scene, camera ); }","title":"Lid"},{"location":"Hardware/Camera/#case","text":"","title":"Case"},{"location":"Hardware/Enclosure%20and%20feet/","text":"Enclosure The enclosure for the physical SSS is made out of two an acryllic ( NOT POLYCARBONATE ) plexiglass fastened together by 18 x M3 screws in a 20mm standoff. The SVG files in hw/enclosure can be loaded onto a plasma/laser cutter to create the pieces. Front Piece The shape and the mounting holes are seen in this figure below: Back Piece The shape and the mounting holes are also seen on this piece. The upper group of 4 holes in the center allows for the mounting of a Raspberry Pi. The lower five are mounting holes for the power and breakout board . The slender slots allow for resistors soldered to the clk and din pins to poke out while the larger openings allow for the commnication and power cable to plug into the SSS's panels. Feet The feet for the SSS are 3D printed pieces that allow for each panel (both front and back) to insert and stand inside it. The more feet are put on the bottom of the enclosure, the more stable it will be. { \"imports\": { \"three\": \"../../assets/three.module.js\" } } import * as THREE from 'three'; import { OrbitControls } from '../../assets/OrbitControls.js'; import { ThreeMFLoader } from '../../assets/3MFLoader.js'; let camera, scene, renderer, object, loader, controls; var container = document.getElementById('camera-lid'); init(); function init() { renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( 500, 300 ); renderer.setClearColor( 0x000000, 0 ); // the default container.appendChild( renderer.domElement ); renderer.domElement.style.cursor = \"grab\"; scene = new THREE.Scene(); scene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) ); camera = new THREE.PerspectiveCamera( 15, window.innerWidth / window.innerHeight, 1, 500 ); // Z is up for objects intended to be 3D printed. camera.up.set( 0, 0, 1 ); camera.position.set( - 100, - 250, 100 ); scene.add( camera ); controls = new OrbitControls( camera, renderer.domElement ); controls.addEventListener( 'change', render ); controls.minDistance = 50; controls.maxDistance = 400; controls.enablePan = false; controls.update(); const pointLight = new THREE.PointLight( 0xffffff, 0.8 ); camera.add( pointLight ); const manager = new THREE.LoadingManager(); manager.onLoad = function () { const aabb = new THREE.Box3().setFromObject( object ); const center = aabb.getCenter( new THREE.Vector3() ); object.position.x += ( object.position.x - center.x ); object.position.y += ( object.position.y - center.y ); object.position.z += ( object.position.z - center.z ); controls.reset(); scene.add( object ); render(); }; loader = new ThreeMFLoader( manager ); loadAsset( '../../assets/feet-sss.3mf' ); // window.addEventListener( 'resize', onWindowResize ); } function loadAsset( asset ) { loader.load( asset, function ( group ) { if ( object ) { object.traverse( function ( child ) { if ( child.material ) child.material.dispose(); if ( child.material && child.material.map ) child.material.map.dispose(); if ( child.geometry ) child.geometry.dispose(); } ); scene.remove( object ); } object = group; } ); } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); render(); } function render() { renderer.render( scene, camera ); }","title":"Enclosure and feet"},{"location":"Hardware/Enclosure%20and%20feet/#enclosure","text":"The enclosure for the physical SSS is made out of two an acryllic ( NOT POLYCARBONATE ) plexiglass fastened together by 18 x M3 screws in a 20mm standoff. The SVG files in hw/enclosure can be loaded onto a plasma/laser cutter to create the pieces.","title":"Enclosure"},{"location":"Hardware/Enclosure%20and%20feet/#front-piece","text":"The shape and the mounting holes are seen in this figure below:","title":"Front Piece"},{"location":"Hardware/Enclosure%20and%20feet/#back-piece","text":"The shape and the mounting holes are also seen on this piece. The upper group of 4 holes in the center allows for the mounting of a Raspberry Pi. The lower five are mounting holes for the power and breakout board . The slender slots allow for resistors soldered to the clk and din pins to poke out while the larger openings allow for the commnication and power cable to plug into the SSS's panels.","title":"Back Piece"},{"location":"Hardware/Enclosure%20and%20feet/#feet","text":"The feet for the SSS are 3D printed pieces that allow for each panel (both front and back) to insert and stand inside it. The more feet are put on the bottom of the enclosure, the more stable it will be. { \"imports\": { \"three\": \"../../assets/three.module.js\" } } import * as THREE from 'three'; import { OrbitControls } from '../../assets/OrbitControls.js'; import { ThreeMFLoader } from '../../assets/3MFLoader.js'; let camera, scene, renderer, object, loader, controls; var container = document.getElementById('camera-lid'); init(); function init() { renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( 500, 300 ); renderer.setClearColor( 0x000000, 0 ); // the default container.appendChild( renderer.domElement ); renderer.domElement.style.cursor = \"grab\"; scene = new THREE.Scene(); scene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) ); camera = new THREE.PerspectiveCamera( 15, window.innerWidth / window.innerHeight, 1, 500 ); // Z is up for objects intended to be 3D printed. camera.up.set( 0, 0, 1 ); camera.position.set( - 100, - 250, 100 ); scene.add( camera ); controls = new OrbitControls( camera, renderer.domElement ); controls.addEventListener( 'change', render ); controls.minDistance = 50; controls.maxDistance = 400; controls.enablePan = false; controls.update(); const pointLight = new THREE.PointLight( 0xffffff, 0.8 ); camera.add( pointLight ); const manager = new THREE.LoadingManager(); manager.onLoad = function () { const aabb = new THREE.Box3().setFromObject( object ); const center = aabb.getCenter( new THREE.Vector3() ); object.position.x += ( object.position.x - center.x ); object.position.y += ( object.position.y - center.y ); object.position.z += ( object.position.z - center.z ); controls.reset(); scene.add( object ); render(); }; loader = new ThreeMFLoader( manager ); loadAsset( '../../assets/feet-sss.3mf' ); // window.addEventListener( 'resize', onWindowResize ); } function loadAsset( asset ) { loader.load( asset, function ( group ) { if ( object ) { object.traverse( function ( child ) { if ( child.material ) child.material.dispose(); if ( child.material && child.material.map ) child.material.map.dispose(); if ( child.geometry ) child.geometry.dispose(); } ); scene.remove( object ); } object = group; } ); } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); render(); } function render() { renderer.render( scene, camera ); }","title":"Feet"},{"location":"Hardware/Final%20product/","text":"Front of SSS Back of SSS SSS in Action","title":"Final product"},{"location":"Hardware/Final%20product/#front-of-sss","text":"","title":"Front of SSS"},{"location":"Hardware/Final%20product/#back-of-sss","text":"","title":"Back of SSS"},{"location":"Hardware/Final%20product/#sss-in-action","text":"","title":"SSS in Action"},{"location":"Hardware/Panel/","text":"The panels of the SSS are the crux of its hardware. If you are going to attempt to replicate the SSS, it is recommended that you look at the the Known Problems and address some of those issues. However, for history and current hardware maintenance sake, we will include the current design of the panels. Panel PCB Blueprints Panel Schematics Each panel has a group of 12 MAX7219 led drivers which control 8 seven segment digits. All of the ICs receive the CS, SCLK, VCC, and GND from a common trace. The MOSI coming from the Raspberry Pi enters into the first IC and is passed through all of them by tying the DOUT (output) of the preceding IC to the DIN (input). The start of the bus for the panel (SV1) receives the following from the power board : GND LOAD (CS) CLK (SCLK) DIN (MOSI) VCC Originally, the panels were going to be connected together by connecting the busses by having a corresponding 5 pins out (SV2) to connect to the next panel's 5 pins in (SV1). This design made the traces very long and was susceptible to noise and caused a lot of screen artifacts. Instead, each panel receives info from the power board via a cable which plugs into the beginning connector of the bus. Not shown in schematic: each SCLK and DIN pin on the IC has a resistor of 200\u03a9+ between it and the trace. This is a hack and should be dealt with in a future hardware design version. Panel PCB The PCB design is a double-sided board. The backside is where the 12 ICs, 12 resistors, 24 capacitors, and 2 cable headers are mounted. The frontside is where the 96 seven segment LED digits are mounted. Panel This is the back view of manufactured panel. Note that the SV1 input from the power board is on the right hand side of the board and that the set of output pin pads need not be used. Known Problems The current version of the SSS panel is flawed. Among the known problems are: The output pins are not needed The data and clock traces are very long, thin, and susceptible to noise. Changing the trace widths and paths would be necessary. Using some sort of differential grounding might also reduce overall board noise. Any efforts to redesign the panels are more than welcome!","title":"Panel"},{"location":"Hardware/Panel/#panel-pcb-blueprints","text":"","title":"Panel PCB Blueprints"},{"location":"Hardware/Panel/#panel-schematics","text":"Each panel has a group of 12 MAX7219 led drivers which control 8 seven segment digits. All of the ICs receive the CS, SCLK, VCC, and GND from a common trace. The MOSI coming from the Raspberry Pi enters into the first IC and is passed through all of them by tying the DOUT (output) of the preceding IC to the DIN (input). The start of the bus for the panel (SV1) receives the following from the power board : GND LOAD (CS) CLK (SCLK) DIN (MOSI) VCC Originally, the panels were going to be connected together by connecting the busses by having a corresponding 5 pins out (SV2) to connect to the next panel's 5 pins in (SV1). This design made the traces very long and was susceptible to noise and caused a lot of screen artifacts. Instead, each panel receives info from the power board via a cable which plugs into the beginning connector of the bus. Not shown in schematic: each SCLK and DIN pin on the IC has a resistor of 200\u03a9+ between it and the trace. This is a hack and should be dealt with in a future hardware design version.","title":"Panel Schematics"},{"location":"Hardware/Panel/#panel-pcb","text":"The PCB design is a double-sided board. The backside is where the 12 ICs, 12 resistors, 24 capacitors, and 2 cable headers are mounted. The frontside is where the 96 seven segment LED digits are mounted.","title":"Panel PCB"},{"location":"Hardware/Panel/#panel","text":"This is the back view of manufactured panel. Note that the SV1 input from the power board is on the right hand side of the board and that the set of output pin pads need not be used.","title":"Panel"},{"location":"Hardware/Panel/#known-problems","text":"The current version of the SSS panel is flawed. Among the known problems are: The output pins are not needed The data and clock traces are very long, thin, and susceptible to noise. Changing the trace widths and paths would be necessary. Using some sort of differential grounding might also reduce overall board noise. Any efforts to redesign the panels are more than welcome!","title":"Known Problems"},{"location":"Hardware/Power%20Board/","text":"Power Board PCB Blueprints The power board is a breakout board which takes the SPI protocol wires from the Raspberry Pi IO and passes them on to the each of the individual panels . Along with the SPI protocol wires, this board will also power the SSS panels. Power Board Schematics The power board receives all of the Raspberry Pi IO on its 8 x 2 Raspberry Pi headers and reroutes them to the BOARD_n headers. These BOARD_n pins will connect to the SV1 pins on the panels. There is also a barrel jack on this board where a DC adapter that outputs 5V and 4A will supply power to all of the ICs and LED seven segment digits on the panels of the SSS. Power Board PCB Power Board","title":"Power Board"},{"location":"Hardware/Power%20Board/#power-board-pcb-blueprints","text":"The power board is a breakout board which takes the SPI protocol wires from the Raspberry Pi IO and passes them on to the each of the individual panels . Along with the SPI protocol wires, this board will also power the SSS panels.","title":"Power Board PCB Blueprints"},{"location":"Hardware/Power%20Board/#power-board-schematics","text":"The power board receives all of the Raspberry Pi IO on its 8 x 2 Raspberry Pi headers and reroutes them to the BOARD_n headers. These BOARD_n pins will connect to the SV1 pins on the panels. There is also a barrel jack on this board where a DC adapter that outputs 5V and 4A will supply power to all of the ICs and LED seven segment digits on the panels of the SSS.","title":"Power Board Schematics"},{"location":"Hardware/Power%20Board/#power-board-pcb","text":"","title":"Power Board PCB"},{"location":"Hardware/Power%20Board/#power-board","text":"","title":"Power Board"},{"location":"Hardware/Raspberry%20Pi%20IO/","text":"At the center of the SSS is the Raspberry Pi, a compact, inexpensive computer that has a very accessible hardware interface. The SSS takes advantage of this interface and connects to all of its panels through the Pi's GPIO. Checkout this link to get an interactive guide to the GPIO. SPI Interface The communication protocol the SSS uses to draw to all of the panels is the Serial Peripheral Interface (or SPI for short). We won't go into the exact details of how this protocol works, but suffice it to say there are several connections necessary to make this work: MOSI (Master Out Slave In) : The actual binary instruction which tell the panel what to draw to the screen. CS (Chip Select) : This wire has to be on (or high) in order to receive and apply instructions from MOSI. There is one of these for each panel in our project. SCLK (Clock Signal) : This wire has an oscillating high-low timing signal that helps all the CS wires and MOSI stay in sync with each other. Device Tree Overlay As you start exploring the Raspberry Pi GPIO its SPI busses (or groups of pins meant to act as a SPI device) you'll notice they only have 1 or 2 CS pins max. This means that by default, a Raspberry Pi can talk to two separate devices (or in our case, panels) at a time. This becomes a problem considering that the SSS has 12 panels! We can overcome this problem by reassigning some of the GPIO pins on the Pi to be CS pins for our SPI bus. To do this, we will need to create a device tree overlay, or a special configuration file which reminds the Raspberry Pi's operating system on startup to make these changes to the pin definitions. Creating the Device Tree Source file For those who are interested to see how this works, please refer to the official documentation from Raspberry Pi on how to create a valid device tree source ( dts ) file and compile it. sss.dts has been provided for those who wish to copy the same configuration as the original SSS or to use it as reference. A brief summary of what is accomplished in the file, the reassigning of certain GPIO pins, is depicted in the table below and can be used as reference in creating altered dts files: GPIO to CS for SPI Bus 0 Reassignment GPIO Pin 6 13 19 26 25 1 12 16 20 21 17 27 22 CS No. 2 3 4 5 6 7 8 9 10 11 12 13 14 Compiling the dts into a dtbo After a correctly formatted dts is made, it needs to be compiled into a device tree blob overlay ( dtbo ). This is a binary file is referred to upon boot and makes the appropriate changes in pin definition. To compile the dts file: dtc -@ -I dts -O dtb -o sss.dtbo sss.dts After the dtbo binary is created, it needs to be moved or copied into the directory where GPIO overlays for the Pis are held: sudo cp sss.dtbo /boot/overlays Finally we will edit the boot config file to let the Pi know that we want to apply the overlay we just created: sudo nano /boot/config.txt Add this line to the file, notice how the first field of the assigned value to dtoverlay is our desired dtbo file name and the rest of the cs<num>_pin correspond to the table in the previous section. dtoverlay=sss,cs2_pin=6,cs3_pin=13,cs4_pin=19,cs5_pin=26,cs6_pin=25,cs7_pin=1,cs8_pin=12,cs9_pin=16,cs10_pin=20,cs11_pin=21,cs12_pin=17,cs13_pin=27,cs14_pin=22 Now reboot your device and the changes should take effect! Pi Wiring In our build of the SSS we connected the GPIO of the Raspberry Pi to a breakout board which distributes the CS signal to its respective panel and the MOSI, SCLK, GND, and VCC signals to the rest.","title":"Raspberry Pi IO"},{"location":"Hardware/Raspberry%20Pi%20IO/#spi-interface","text":"The communication protocol the SSS uses to draw to all of the panels is the Serial Peripheral Interface (or SPI for short). We won't go into the exact details of how this protocol works, but suffice it to say there are several connections necessary to make this work: MOSI (Master Out Slave In) : The actual binary instruction which tell the panel what to draw to the screen. CS (Chip Select) : This wire has to be on (or high) in order to receive and apply instructions from MOSI. There is one of these for each panel in our project. SCLK (Clock Signal) : This wire has an oscillating high-low timing signal that helps all the CS wires and MOSI stay in sync with each other.","title":"SPI Interface"},{"location":"Hardware/Raspberry%20Pi%20IO/#device-tree-overlay","text":"As you start exploring the Raspberry Pi GPIO its SPI busses (or groups of pins meant to act as a SPI device) you'll notice they only have 1 or 2 CS pins max. This means that by default, a Raspberry Pi can talk to two separate devices (or in our case, panels) at a time. This becomes a problem considering that the SSS has 12 panels! We can overcome this problem by reassigning some of the GPIO pins on the Pi to be CS pins for our SPI bus. To do this, we will need to create a device tree overlay, or a special configuration file which reminds the Raspberry Pi's operating system on startup to make these changes to the pin definitions.","title":"Device Tree Overlay"},{"location":"Hardware/Raspberry%20Pi%20IO/#creating-the-device-tree-source-file","text":"For those who are interested to see how this works, please refer to the official documentation from Raspberry Pi on how to create a valid device tree source ( dts ) file and compile it. sss.dts has been provided for those who wish to copy the same configuration as the original SSS or to use it as reference. A brief summary of what is accomplished in the file, the reassigning of certain GPIO pins, is depicted in the table below and can be used as reference in creating altered dts files:","title":"Creating the Device Tree Source file"},{"location":"Hardware/Raspberry%20Pi%20IO/#gpio-to-cs-for-spi-bus-0-reassignment","text":"GPIO Pin 6 13 19 26 25 1 12 16 20 21 17 27 22 CS No. 2 3 4 5 6 7 8 9 10 11 12 13 14","title":"GPIO to CS for SPI Bus 0 Reassignment"},{"location":"Hardware/Raspberry%20Pi%20IO/#compiling-the-dts-into-a-dtbo","text":"After a correctly formatted dts is made, it needs to be compiled into a device tree blob overlay ( dtbo ). This is a binary file is referred to upon boot and makes the appropriate changes in pin definition. To compile the dts file: dtc -@ -I dts -O dtb -o sss.dtbo sss.dts After the dtbo binary is created, it needs to be moved or copied into the directory where GPIO overlays for the Pis are held: sudo cp sss.dtbo /boot/overlays Finally we will edit the boot config file to let the Pi know that we want to apply the overlay we just created: sudo nano /boot/config.txt Add this line to the file, notice how the first field of the assigned value to dtoverlay is our desired dtbo file name and the rest of the cs<num>_pin correspond to the table in the previous section. dtoverlay=sss,cs2_pin=6,cs3_pin=13,cs4_pin=19,cs5_pin=26,cs6_pin=25,cs7_pin=1,cs8_pin=12,cs9_pin=16,cs10_pin=20,cs11_pin=21,cs12_pin=17,cs13_pin=27,cs14_pin=22 Now reboot your device and the changes should take effect!","title":"Compiling the dts into a dtbo"},{"location":"Hardware/Raspberry%20Pi%20IO/#pi-wiring","text":"In our build of the SSS we connected the GPIO of the Raspberry Pi to a breakout board which distributes the CS signal to its respective panel and the MOSI, SCLK, GND, and VCC signals to the rest.","title":"Pi Wiring"},{"location":"Installation/Install%20SSS%20on%20Mac%20or%20Linux/","text":"Checking Dependencies To install the SSS on your Mac or Linux device, you will need some certain dependencies. You can get them from your package manager by doing the following This project only uses python3 . Check to see if you are using python3 by: python -V If your system has multiple versions of python installed, you can force v3 by replacing all python and pip commands with python3 and pip3 . For Mac Make sure that you have homebrew installed and then run the following: curl https://bootstrap.pypa.io/get-pip.py | python && brew install git virtualenv For Linux If you are using Ubuntu or any other Debian based Linux distro with the apt package manager: sudo apt install git python3-virtualenv If you are using RedHat or any of its variants that uses dnf : sudo dnf install git python-virtualenv Setting up SSS Once you have all the dependencies for your system installed, you can now move onto downloading and setting up the SSS on your system. The following steps should be system-agnostic. First we'll get the code from GitHub by cloning the repository: git clone git@github.com:NET-BYU/sss.git Now we'll move into the folder and make sure our virtual environment is set up: cd sss # Change to SSS project directory virtualenv venv # Create a python virtual environment called venv source venv/bin/activate # Activate the venv environment You should notice the prompt of your terminal change to indicate that you are now in your newly created python virtual environment. All of the following steps assume you are within this environment. If you are not, you will install all SSS dependencies system-wide which may conflict with some previous configurations. Then you will need to install all the python requirements for the SSS: python3 -m pip install -r requirements.txt And that's it! Once this has successfully completed, you are ready to run the simulator and start developing for the SSS! For more information, go to Get Started .","title":"Install SSS on Mac or Linux"},{"location":"Installation/Install%20SSS%20on%20Mac%20or%20Linux/#checking-dependencies","text":"To install the SSS on your Mac or Linux device, you will need some certain dependencies. You can get them from your package manager by doing the following This project only uses python3 . Check to see if you are using python3 by: python -V If your system has multiple versions of python installed, you can force v3 by replacing all python and pip commands with python3 and pip3 .","title":"Checking Dependencies"},{"location":"Installation/Install%20SSS%20on%20Mac%20or%20Linux/#for-mac","text":"Make sure that you have homebrew installed and then run the following: curl https://bootstrap.pypa.io/get-pip.py | python && brew install git virtualenv","title":"For Mac"},{"location":"Installation/Install%20SSS%20on%20Mac%20or%20Linux/#for-linux","text":"If you are using Ubuntu or any other Debian based Linux distro with the apt package manager: sudo apt install git python3-virtualenv If you are using RedHat or any of its variants that uses dnf : sudo dnf install git python-virtualenv","title":"For Linux"},{"location":"Installation/Install%20SSS%20on%20Mac%20or%20Linux/#setting-up-sss","text":"Once you have all the dependencies for your system installed, you can now move onto downloading and setting up the SSS on your system. The following steps should be system-agnostic. First we'll get the code from GitHub by cloning the repository: git clone git@github.com:NET-BYU/sss.git Now we'll move into the folder and make sure our virtual environment is set up: cd sss # Change to SSS project directory virtualenv venv # Create a python virtual environment called venv source venv/bin/activate # Activate the venv environment You should notice the prompt of your terminal change to indicate that you are now in your newly created python virtual environment. All of the following steps assume you are within this environment. If you are not, you will install all SSS dependencies system-wide which may conflict with some previous configurations. Then you will need to install all the python requirements for the SSS: python3 -m pip install -r requirements.txt And that's it! Once this has successfully completed, you are ready to run the simulator and start developing for the SSS! For more information, go to Get Started .","title":"Setting up SSS"},{"location":"Installation/Install%20SSS%20on%20Windows/","text":"Checking Dependencies To install the SSS on your Windows device, you will need some certain dependencies. You can get them from your package manager by doing the following You will need to install Python 3 on your computer if you don't have it installed already. You will also need a git on your machine and some way to interface with it. We recommend Git Bash . Once that is succesfully set up, you will need to make sure that pip is installed on your machine as well. Enter the following in your cmd: curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py With pip installed we can now install virtualenv : python3 -m pip install --user virtualenv Setting up SSS Once you have all the dependencies for your system installed, you can now move onto downloading and setting up the SSS on your system. First we'll get the code from GitHub by cloning the repository. Open up your Git Bash program and make sure that you are in your desired folder for downloading. Then clone the repo: git clone git@github.com:NET-BYU/sss.git Now with cmd, go to the folder where you cloned the repo. cd <path\\ to\\ repo>\\sss :: Change to SSS project directory Then we will make sure that we create a virtual environment for all the python dependencies python -m venv venv :: Create a python virtual environment called venv .\\venv\\Scripts\\activate :: Activate the venv environment You should notice the prompt of your terminal change to indicate that you are now in your newly created python virtual environment. All of the following steps assume you are within this environment. If you are not, you will install all SSS dependencies system-wide which may conflict with some previous configurations. Then you will need to install all the python requirements for the SSS: pip install -r requirements.txt And that's it! Once this has successfully completed, you are ready to run the simulator and start developing for the SSS! For more information, go to Get Started . Running on Windows It its current state, the SSS cannot autoload all of the demos in kiosk, testing, and simulator mode. This may be fixed in a future release.","title":"Install SSS on Windows"},{"location":"Installation/Install%20SSS%20on%20Windows/#checking-dependencies","text":"To install the SSS on your Windows device, you will need some certain dependencies. You can get them from your package manager by doing the following You will need to install Python 3 on your computer if you don't have it installed already. You will also need a git on your machine and some way to interface with it. We recommend Git Bash . Once that is succesfully set up, you will need to make sure that pip is installed on your machine as well. Enter the following in your cmd: curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py With pip installed we can now install virtualenv : python3 -m pip install --user virtualenv","title":"Checking Dependencies"},{"location":"Installation/Install%20SSS%20on%20Windows/#setting-up-sss","text":"Once you have all the dependencies for your system installed, you can now move onto downloading and setting up the SSS on your system. First we'll get the code from GitHub by cloning the repository. Open up your Git Bash program and make sure that you are in your desired folder for downloading. Then clone the repo: git clone git@github.com:NET-BYU/sss.git Now with cmd, go to the folder where you cloned the repo. cd <path\\ to\\ repo>\\sss :: Change to SSS project directory Then we will make sure that we create a virtual environment for all the python dependencies python -m venv venv :: Create a python virtual environment called venv .\\venv\\Scripts\\activate :: Activate the venv environment You should notice the prompt of your terminal change to indicate that you are now in your newly created python virtual environment. All of the following steps assume you are within this environment. If you are not, you will install all SSS dependencies system-wide which may conflict with some previous configurations. Then you will need to install all the python requirements for the SSS: pip install -r requirements.txt And that's it! Once this has successfully completed, you are ready to run the simulator and start developing for the SSS! For more information, go to Get Started .","title":"Setting up SSS"},{"location":"Installation/Install%20SSS%20on%20Windows/#running-on-windows","text":"It its current state, the SSS cannot autoload all of the demos in kiosk, testing, and simulator mode. This may be fixed in a future release.","title":"Running on Windows"},{"location":"Overview/About%20the%20team/","text":"Since its inception at the end of summer in 2021 the list of contributors for the SSS has grown significantly. The first version of the system and winner of the BYU IT&CSA Raspberry Pi 2021 competition was designed and developed by Dinah Bronson , Ashton Palacios , Chris Kitras , and Phil Lundrigan . Since that first edition, the number of contributors has doubled mainly with new researchers from the BYU NET Lab , each contributing one or more unique demos! If you are interested in helping the maintain or develop for the SSS, feel free to open a PR and get started by creating a demo .","title":"About the team"},{"location":"Overview/Get%20started/","text":"To get started with the SSS, you will first need to make sure that it is installed on your machine. There are guides for both Mac and Linux and Windows . Once you have completed this step, you are ready to start tinkering! Configuring the Environment As was seen in the installation guides, most of the python libraries which the SSS depends on have been installed in a virtual environment. You will need to make sure that you have activated this environment before running the SSS or else you are bound to run into errors that claim you are missing dependencies/libraries. First, make sure you are in the folder where the SSS code is at (in the terminal), and then: Mac or Linux source venv/bin/activate Windows .\\venv\\Scripts\\activate Modes We realize most people will never run the SSS on its original hardware and most likely will be tinkering with a simulated version. However, the code supports both execution in the original physical environment and on the simulator. Whenever you want to run a command for the SSS that will be simulated, add a -s flag at the end, else the program will try to run on a physical screen and will most likely crash if you do not have one. Simulator Simulator mode opens a window with controls to choose through all of the demos. python main.py simulator This mode is not functional in Windows Kiosk Kiosk mode can be though of as screen-saver mode. The SSS will cycle through demos that have a demo_time other than None (i.e. everything but games). To run in this mode: python main.py kiosk # Don't forget to add \"-s\" if simulating This mode is not functional in Windows This mode comes with an optional --testing flag to speed up demo_time s so that you can cycle through demos faster and catch errors more quickly. Demo If you want to execute a specific demo instead of waiting for it in kiosk mode, you can use demo mode! Any demo (including games) are available in this mode and will try to use the keyboard as the default input device: python main.py demo <demo name here> # Don't forget to add \"-s\" if simulating Testing Finally, if you simply want to make sure that all the demos in the SSS are running correctly (including yours), run: python main.py testing This mode is not functional in Windows To execute each demo for a few cycles to make sure everything has initialized and run correctly. What Next? Now that you have figured out how to run the SSS in its different modes, why not try making something? Take a look at our Tutorials section, especially Creating a Demo to see how you can make your own interactive demos.","title":"Get started"},{"location":"Overview/Get%20started/#configuring-the-environment","text":"As was seen in the installation guides, most of the python libraries which the SSS depends on have been installed in a virtual environment. You will need to make sure that you have activated this environment before running the SSS or else you are bound to run into errors that claim you are missing dependencies/libraries. First, make sure you are in the folder where the SSS code is at (in the terminal), and then:","title":"Configuring the Environment"},{"location":"Overview/Get%20started/#mac-or-linux","text":"source venv/bin/activate","title":"Mac or Linux"},{"location":"Overview/Get%20started/#windows","text":".\\venv\\Scripts\\activate","title":"Windows"},{"location":"Overview/Get%20started/#modes","text":"We realize most people will never run the SSS on its original hardware and most likely will be tinkering with a simulated version. However, the code supports both execution in the original physical environment and on the simulator. Whenever you want to run a command for the SSS that will be simulated, add a -s flag at the end, else the program will try to run on a physical screen and will most likely crash if you do not have one.","title":"Modes"},{"location":"Overview/Get%20started/#simulator","text":"Simulator mode opens a window with controls to choose through all of the demos. python main.py simulator This mode is not functional in Windows","title":"Simulator"},{"location":"Overview/Get%20started/#kiosk","text":"Kiosk mode can be though of as screen-saver mode. The SSS will cycle through demos that have a demo_time other than None (i.e. everything but games). To run in this mode: python main.py kiosk # Don't forget to add \"-s\" if simulating This mode is not functional in Windows This mode comes with an optional --testing flag to speed up demo_time s so that you can cycle through demos faster and catch errors more quickly.","title":"Kiosk"},{"location":"Overview/Get%20started/#demo","text":"If you want to execute a specific demo instead of waiting for it in kiosk mode, you can use demo mode! Any demo (including games) are available in this mode and will try to use the keyboard as the default input device: python main.py demo <demo name here> # Don't forget to add \"-s\" if simulating","title":"Demo"},{"location":"Overview/Get%20started/#testing","text":"Finally, if you simply want to make sure that all the demos in the SSS are running correctly (including yours), run: python main.py testing This mode is not functional in Windows To execute each demo for a few cycles to make sure everything has initialized and run correctly.","title":"Testing"},{"location":"Overview/Get%20started/#what-next","text":"Now that you have figured out how to run the SSS in its different modes, why not try making something? Take a look at our Tutorials section, especially Creating a Demo to see how you can make your own interactive demos.","title":"What Next?"},{"location":"Overview/Introduction/","text":"Introduction The Seven Segment Sign, or SSS for short, is a purely Python, Raspberry Pi-powered system that drives a screen of 1152 seven segment digits (arranged in a 48 x 24 array). But don't let these low specs fool you! This platform provides a beginner-friendly opportunity for anyone to learn how to address complex design problems with strict limitations. Some of the initial demos we've been able to make work are: Video Player Arcade Games and even Doom! What next? Even though the physical SSS resides in the BYU NET Lab , the source code, blueprints, and a simulator are all available on GitHub and this wiki! Take a look at the following links to help you get started: Get started Support Happy hacking!","title":"Introduction"},{"location":"Overview/Introduction/#introduction","text":"The Seven Segment Sign, or SSS for short, is a purely Python, Raspberry Pi-powered system that drives a screen of 1152 seven segment digits (arranged in a 48 x 24 array). But don't let these low specs fool you! This platform provides a beginner-friendly opportunity for anyone to learn how to address complex design problems with strict limitations. Some of the initial demos we've been able to make work are:","title":"Introduction"},{"location":"Overview/Introduction/#video-player","text":"","title":"Video Player"},{"location":"Overview/Introduction/#arcade-games","text":"","title":"Arcade Games"},{"location":"Overview/Introduction/#and-even-doom","text":"","title":"and even Doom!"},{"location":"Overview/Introduction/#what-next","text":"Even though the physical SSS resides in the BYU NET Lab , the source code, blueprints, and a simulator are all available on GitHub and this wiki! Take a look at the following links to help you get started: Get started Support Happy hacking!","title":"What next?"},{"location":"Simulator/Introduction/","text":"simulator.py This file holds the class definitions to both the individually simulated digit and individually simulated panels. Digit This class controls drawing the individual lines and dot of a seven segment digit. The init parameters consists of a display object, and x and y coordinates. The display object is a pygame surface object. The x and y coordinates are the top left corner of the digit on the passed in pygame surface display object. There is one member function called update. This takes a value that corresponds to each of the seven segments and the dot. The bit order is DP-A-B-C-D-E-F-G. It only updates the values that need to change. Panel This class is all about simulating a hardware panel. It is 16 digits across and 6 digits down. The init function parameters are start_x, start_y, and display. These are the same concept as the Digit class above. The display parameter is a pygame surface object. The start_x and start_y parameters are the x y coordinates of the upper left hand corner on the pygame surface display object. This class has three members to mimic the functionality of the hardware panels. The first is raw2. This function takes x, y, value, and flush parameters. The x and y parameters controls which digit to draw on. The value parameter is value to be written to digit. The bit order is stated above in the Digit class. The flush parameters controls if the change to the digit gets updated with this function call. The flush function will take all of the changes to the digits that haven\u2019t been displayed yet and \u201cflips\u201d it to the screen. The clear function does just that, clears the panel Standalone_sim.py ThIs file holds the Simulator class and instantiation. The Simulator class creates a stand alone simulator of the physical SSS. Many of the methods in the class are to only be used internally and wouldn\u2019t be called outside of the class. The init function takes the width, height, and demo_dir parameters. The width and height parameters are the pixel width and height values of the display. These values are 48 and 48. The demo_dir is the directory of where the demos are. This value shouldn\u2019t generally be changed from the inherent value unless your demos are put else where. The start the simulator, instantiate a Simulator object and call the start method. The start method has a pygame control loop that handles the display. The simulator will hot load all the demos in the demo_dir location. It will create a clickable list of demos on the left side of the screen. On the top of this list is a reload button. Demos can be changed while the simulator is running and be hot reloaded. Upon clicking reload, make sure to reclick the demo you want to run to ensure the changes are activated. There is a more button at the bottom of the list. This button will go to the next set of demos is the number of demos is greater than 13. Continue to click on more to cycle through each page of demos. On the bottom of the simulator there is a black box. It may be concerning to see your demo not go all the way to the bottom of the screen. Don\u2019t panic, that is normal. This special area shows when LIVES and SCORE updates are published on the output of your demo. You can input left, right, up, down, and enter commands to your game by pressing the left, right, up, down, enter keys. When you press one of those keys it will send a press command. When that key is released, it will also send a release command. When designing games it is important to remember that these two types of commands get sent. For an example of processing these commands checkout the playable snake and breakout games.","title":"Introduction"},{"location":"Simulator/Introduction/#simulatorpy","text":"This file holds the class definitions to both the individually simulated digit and individually simulated panels.","title":"simulator.py"},{"location":"Simulator/Introduction/#digit","text":"This class controls drawing the individual lines and dot of a seven segment digit. The init parameters consists of a display object, and x and y coordinates. The display object is a pygame surface object. The x and y coordinates are the top left corner of the digit on the passed in pygame surface display object. There is one member function called update. This takes a value that corresponds to each of the seven segments and the dot. The bit order is DP-A-B-C-D-E-F-G. It only updates the values that need to change.","title":"Digit"},{"location":"Simulator/Introduction/#panel","text":"This class is all about simulating a hardware panel. It is 16 digits across and 6 digits down. The init function parameters are start_x, start_y, and display. These are the same concept as the Digit class above. The display parameter is a pygame surface object. The start_x and start_y parameters are the x y coordinates of the upper left hand corner on the pygame surface display object. This class has three members to mimic the functionality of the hardware panels. The first is raw2. This function takes x, y, value, and flush parameters. The x and y parameters controls which digit to draw on. The value parameter is value to be written to digit. The bit order is stated above in the Digit class. The flush parameters controls if the change to the digit gets updated with this function call. The flush function will take all of the changes to the digits that haven\u2019t been displayed yet and \u201cflips\u201d it to the screen. The clear function does just that, clears the panel","title":"Panel"},{"location":"Simulator/Introduction/#standalone_simpy","text":"ThIs file holds the Simulator class and instantiation. The Simulator class creates a stand alone simulator of the physical SSS. Many of the methods in the class are to only be used internally and wouldn\u2019t be called outside of the class. The init function takes the width, height, and demo_dir parameters. The width and height parameters are the pixel width and height values of the display. These values are 48 and 48. The demo_dir is the directory of where the demos are. This value shouldn\u2019t generally be changed from the inherent value unless your demos are put else where. The start the simulator, instantiate a Simulator object and call the start method. The start method has a pygame control loop that handles the display. The simulator will hot load all the demos in the demo_dir location. It will create a clickable list of demos on the left side of the screen. On the top of this list is a reload button. Demos can be changed while the simulator is running and be hot reloaded. Upon clicking reload, make sure to reclick the demo you want to run to ensure the changes are activated. There is a more button at the bottom of the list. This button will go to the next set of demos is the number of demos is greater than 13. Continue to click on more to cycle through each page of demos. On the bottom of the simulator there is a black box. It may be concerning to see your demo not go all the way to the bottom of the screen. Don\u2019t panic, that is normal. This special area shows when LIVES and SCORE updates are published on the output of your demo. You can input left, right, up, down, and enter commands to your game by pressing the left, right, up, down, enter keys. When you press one of those keys it will send a press command. When that key is released, it will also send a release command. When designing games it is important to remember that these two types of commands get sent. For an example of processing these commands checkout the playable snake and breakout games.","title":"Standalone_sim.py"},{"location":"Troubleshooting/Common%20issues/","text":"General SSS FAQ Errors stating that there isn't a specific Python module installed when it is After the initial installation and running of the program, users may find that upon returning to run the program again, they are met with errors that state they do not have the right Python Modules installed. There are several reasons that could cause this: Not using the venv for SSS Make sure that you are running the SSS inside the virtual environment by running: which python If the response string does not indicate that the python interpreter is coming from a virtual environment, for example: /usr/bin/python Then make sure to activate the virtual environment created for the SSS: source ~/sss/venv/bin/activate # Make sure this is the path to your venv Then check the python interpreter being used again. It should look something like the following: which python ./venv/bin/python Installed python modules in wrong environment During the setup process of the SSS, it is possible that you may not have entered into the virtual environment made for the project before installing the dependencies found in requirements.txt. To see if these modules exist in your virtual environment: First activate the created environment: source ~/sss/venv/bin/activate # Make sure this is the path to your venv Check the list of installed modules in the venv: pip freeze # Shows list of python modules installed in venv If the list of packages printed includes the dependencies found in requirements.txt, then you should be good and a further issue should be opened on the repository. Physical SSS FAQ There is no drawing on the screen even though there is terminal output If there is no drawing on the screen but the terminal output from the program indicates no errors, this indicates that there is something wrong with the hardware itself. There are several things you can check to rule out serious damage first: Make sure the screen is plugged in. Often times this is the most overlooked problem Restart the SSS hardware. Unplug everything from the wall. Plug in the Raspberry Pi. Log into the Pi's OS. Plug in the screen hardware. Doing the preceding in this order allows the SSS program to detect the ICs in the screen in a determined (uninitialized) state. Check the continuity of the traces between joints in any of the circuits that carry power. I plugged in the screen but it is flashing red, random patterns. What do I do? Normally if the screen is flashing red sporadically, this is indicative of the ICs on the screen being in an uncertain state. The best thing to do is the following: Unplug everything from the wall. Plug in the Raspberry Pi. Log into the Pi's OS. Plug in the screen hardware. Doing the preceding in this order allows the ICs to be reset from their undetermined state. Why are there random artifacts left on the screen as a demo is running? If a demo is executing normally, but then random digits on the SSS start to display unexpected patterns, this is most likely due to the refresh rate of the ICs being too high. Because the traces and wires on the SSS are somewhat long, this means that the signal is more susceptible to delay and noise. The faster the ICs try to refresh at, the more likely it is for the data to miss the SCLK rising window. To mititgate this issue, we will need to modify the seven_seg.py file in the display directory. To edit the file use your favorite text editor and open up the sss/display/seven_seg.py file. Then we will need to modify the following line: DEFAULT_BAUDRATE = 3000000 # Refresh rate of the ICs is currently set to 3MHz Dropping the DEFAULT_BAUDRATE value is a quick way to clear up artifacts. However, this also comes with the unfortunate side effect of slowing the execution of the SSS down. A more sure-fire way to fix this problem would be to redesign the panels of the screen to minimize the length of the traces and also make the width thicker. Furthermore, a more concerted effort to reduce noise in the overall design would more effectivly mitigate signal corruption. Simulator SSS FAQ None of my outputs seem to work with the simulator. As of this revision of the SSS, no output handling has been implemented for the simulator, although it is definitely a TODO. If there are any other questions that you have concerning the use of the SSS project, please feel free to go to the support page and follow the links to open an issue.","title":"Common issues"},{"location":"Troubleshooting/Common%20issues/#general-sss-faq","text":"Errors stating that there isn't a specific Python module installed when it is After the initial installation and running of the program, users may find that upon returning to run the program again, they are met with errors that state they do not have the right Python Modules installed. There are several reasons that could cause this:","title":"General SSS FAQ"},{"location":"Troubleshooting/Common%20issues/#physical-sss-faq","text":"There is no drawing on the screen even though there is terminal output If there is no drawing on the screen but the terminal output from the program indicates no errors, this indicates that there is something wrong with the hardware itself. There are several things you can check to rule out serious damage first: Make sure the screen is plugged in. Often times this is the most overlooked problem Restart the SSS hardware. Unplug everything from the wall. Plug in the Raspberry Pi. Log into the Pi's OS. Plug in the screen hardware. Doing the preceding in this order allows the SSS program to detect the ICs in the screen in a determined (uninitialized) state. Check the continuity of the traces between joints in any of the circuits that carry power. I plugged in the screen but it is flashing red, random patterns. What do I do? Normally if the screen is flashing red sporadically, this is indicative of the ICs on the screen being in an uncertain state. The best thing to do is the following: Unplug everything from the wall. Plug in the Raspberry Pi. Log into the Pi's OS. Plug in the screen hardware. Doing the preceding in this order allows the ICs to be reset from their undetermined state. Why are there random artifacts left on the screen as a demo is running? If a demo is executing normally, but then random digits on the SSS start to display unexpected patterns, this is most likely due to the refresh rate of the ICs being too high. Because the traces and wires on the SSS are somewhat long, this means that the signal is more susceptible to delay and noise. The faster the ICs try to refresh at, the more likely it is for the data to miss the SCLK rising window. To mititgate this issue, we will need to modify the seven_seg.py file in the display directory. To edit the file use your favorite text editor and open up the sss/display/seven_seg.py file. Then we will need to modify the following line: DEFAULT_BAUDRATE = 3000000 # Refresh rate of the ICs is currently set to 3MHz Dropping the DEFAULT_BAUDRATE value is a quick way to clear up artifacts. However, this also comes with the unfortunate side effect of slowing the execution of the SSS down. A more sure-fire way to fix this problem would be to redesign the panels of the screen to minimize the length of the traces and also make the width thicker. Furthermore, a more concerted effort to reduce noise in the overall design would more effectivly mitigate signal corruption.","title":"Physical SSS FAQ"},{"location":"Troubleshooting/Common%20issues/#simulator-sss-faq","text":"None of my outputs seem to work with the simulator. As of this revision of the SSS, no output handling has been implemented for the simulator, although it is definitely a TODO. If there are any other questions that you have concerning the use of the SSS project, please feel free to go to the support page and follow the links to open an issue.","title":"Simulator SSS FAQ"},{"location":"Troubleshooting/Support/","text":"Support As of the latest release, the SSS has been solely developed by students inside of the BYU NET Lab and participants in the BYU ECEN IMMERSE 2022 program. While we might not have the exact same group to maintain the demos they made over the summer, the current group of students in the lab frequently monitor the issues and pull requests on the repository. Please feel free to open either and issue or pull request at any time!","title":"Support"},{"location":"Troubleshooting/Support/#support","text":"As of the latest release, the SSS has been solely developed by students inside of the BYU NET Lab and participants in the BYU ECEN IMMERSE 2022 program. While we might not have the exact same group to maintain the demos they made over the summer, the current group of students in the lab frequently monitor the issues and pull requests on the repository. Please feel free to open either and issue or pull request at any time!","title":"Support"},{"location":"Tutorials/Adding%20Input%20Controllers/","text":"Adding Input Controllers One of the central ideas of the SSS is that any demo can receive any type of input as long as it is formatted correctly. Adding an input to the SSS is not particularly difficult to do, but requires: 1. The correct initialization of the input device/service in __init__.py in the controllers module 2. The actual driver file which contains the logic that forms the input and places it in the correct system queue (this will be it's own separate python file in the controllers directory). controllers module Much like the demos module which contains all of the games and demos the SSS runs, the controllers module is the central location where all of the input devices/services pass information into the demo's input_queue . Just like a normal Python module, all of the initialization for this module takes place in the __init__.py . In the controllers module, the __init__.py is where all the controller services are initialized, checked for exceptions, and processed for the information to be put on the demos' input_queue . Initializing the input controller In the __init__.py file, there is only one function: start_inputs(system_queue, demo_input_queue) which initializes all controllers and attaches them to the system_queue and the demo_input_queue . The beginning of this function is where we initialize the runner for our new input. We do this by declaring a variable and assigning it to the return value of our input driver's start_processing_input() function. In some cases, the initialization status of a controller will be provided from a different function (i.e. the keyboard driver for the simulator). Make sure you wrap the runner declaration inside of a try/execpt statement so if it fails, the entire SSS won't crash. In the case that the initialization runs into an exception, be sure to assign the runner to None . try : from . import example # This imports the actual input driver example_runner = example . start_processing_input ( system_queue , demo_input_queue ) except Exception as e : example_runner = None Polling from the controllers At the bottom of start_inputs is an infinite loop which will yields all of the inputs from each of the successfully initialized controllers into the appropriate system queues on every tick. To ensure that your controller has its inputs polled for every tick of the program, call next() on the generator declared: if example_runner : next ( example_runner ) The result The following is a simplified result of what the __init__.py file should look like after having set up our example input. from loguru import logger def start_inputs ( system_queue , demo_input_queue ): try : logger . info ( \"Loading my example input...\" ) from . import example # This imports the actual input driver example_runner = example . start_processing_input ( system_queue , demo_input_queue ) logger . info ( \"...done\" ) except Exception as e : example_runner = None logger . warning ( e ) logger . warning ( \"Reason for input initialization failure will go here.\" ) logger . warning ( \"Program will continue to run without this input.\" ) # More inputs are declared and initialized here while True : if example_runner : next ( example_runner ) # More input runners are `ticked` through here yield Input Driver File The contents of your input driver file varies widely based on your method of generating input. The only requirement for each input driver file is a start_processing_input(system_queue, demo_input_queue) function which should contain a generator that will store input values in the correct queues before each yield . Depending on how your controlling service/device API works, you should return None from start_processing_input , throw an exception, or have a distinct function that checks initializability altogether in the case that it cannot start correctly. example.py Driver Below is an arbitrary example skeleton file of what an input driver should contain. For more concrete examples, look at the the mqtt or keyboard drivers. # Example input driver file from example_device import inputs def start_processing_input ( system_queue , demo_input_queue ): while True : events = inputs . events . get () for event in inputs . events : # Check for KEYDOWN event and pass into input queue if event . type == inputs . KEYDOWN : if event . key == ESCAPE : system_queue . put ( \"QUIT\" ) elif event . key == LEFT : demo_input_queue . put ( \"LEFT_P\" ) # Continues for all key presses... # check for KEYUP event and pass into input queue elif event . type == inputs . KEYUP : if event . key == LEFT : demo_input_queue . put ( \"LEFT_R\" ) elif event . key == UP : demo_input_queue . put ( \"UP_R\" ) # Continues for all key releases... # Check for QUIT event. elif event . type == QUIT : system_queue . put ( \"QUIT\" ) inputs . update ( events ) yield Input Values Generally supported input values For an input controller to be compatible with all of the demos in the SSS system, the following input messages need to be handled: Value Description LEFT_P Left arrow pressed LEFT_R Left arrow released RIGHT_P Right arrow pressed RIGHT_P Right arrow released UP_P Up arrow pressed UP_R Up arrow released DOWN_P Down arrow pressed DOWN_R Down arrow released START_P Start button pressed START_R Start button released SEL_P Select button pressed SEL_R Select button released PRI_P Primary action button pressed PRI_R Primary action button released SEC_P Secondary action button pressed SEC_R Secondary action button released Demo specific input values As of the current version of the SSS, there is no system-wide mechanism for handling demo-specific input. However, the assumption could be made that if only the specific controller and demo could understand the type of messages sent on the demo_input_queue and therefore this would not affect normal operation. Yet, this is untested behavior and is done at the risk of that specific input driver's authors/users.","title":"Adding Input Controllers"},{"location":"Tutorials/Adding%20Input%20Controllers/#adding-input-controllers","text":"One of the central ideas of the SSS is that any demo can receive any type of input as long as it is formatted correctly. Adding an input to the SSS is not particularly difficult to do, but requires: 1. The correct initialization of the input device/service in __init__.py in the controllers module 2. The actual driver file which contains the logic that forms the input and places it in the correct system queue (this will be it's own separate python file in the controllers directory).","title":"Adding Input Controllers"},{"location":"Tutorials/Adding%20Input%20Controllers/#controllers-module","text":"Much like the demos module which contains all of the games and demos the SSS runs, the controllers module is the central location where all of the input devices/services pass information into the demo's input_queue . Just like a normal Python module, all of the initialization for this module takes place in the __init__.py . In the controllers module, the __init__.py is where all the controller services are initialized, checked for exceptions, and processed for the information to be put on the demos' input_queue .","title":"controllers module"},{"location":"Tutorials/Adding%20Input%20Controllers/#initializing-the-input-controller","text":"In the __init__.py file, there is only one function: start_inputs(system_queue, demo_input_queue) which initializes all controllers and attaches them to the system_queue and the demo_input_queue . The beginning of this function is where we initialize the runner for our new input. We do this by declaring a variable and assigning it to the return value of our input driver's start_processing_input() function. In some cases, the initialization status of a controller will be provided from a different function (i.e. the keyboard driver for the simulator). Make sure you wrap the runner declaration inside of a try/execpt statement so if it fails, the entire SSS won't crash. In the case that the initialization runs into an exception, be sure to assign the runner to None . try : from . import example # This imports the actual input driver example_runner = example . start_processing_input ( system_queue , demo_input_queue ) except Exception as e : example_runner = None","title":"Initializing the input controller"},{"location":"Tutorials/Adding%20Input%20Controllers/#polling-from-the-controllers","text":"At the bottom of start_inputs is an infinite loop which will yields all of the inputs from each of the successfully initialized controllers into the appropriate system queues on every tick. To ensure that your controller has its inputs polled for every tick of the program, call next() on the generator declared: if example_runner : next ( example_runner )","title":"Polling from the controllers"},{"location":"Tutorials/Adding%20Input%20Controllers/#the-result","text":"The following is a simplified result of what the __init__.py file should look like after having set up our example input. from loguru import logger def start_inputs ( system_queue , demo_input_queue ): try : logger . info ( \"Loading my example input...\" ) from . import example # This imports the actual input driver example_runner = example . start_processing_input ( system_queue , demo_input_queue ) logger . info ( \"...done\" ) except Exception as e : example_runner = None logger . warning ( e ) logger . warning ( \"Reason for input initialization failure will go here.\" ) logger . warning ( \"Program will continue to run without this input.\" ) # More inputs are declared and initialized here while True : if example_runner : next ( example_runner ) # More input runners are `ticked` through here yield","title":"The result"},{"location":"Tutorials/Adding%20Input%20Controllers/#input-driver-file","text":"The contents of your input driver file varies widely based on your method of generating input. The only requirement for each input driver file is a start_processing_input(system_queue, demo_input_queue) function which should contain a generator that will store input values in the correct queues before each yield . Depending on how your controlling service/device API works, you should return None from start_processing_input , throw an exception, or have a distinct function that checks initializability altogether in the case that it cannot start correctly.","title":"Input Driver File"},{"location":"Tutorials/Adding%20Input%20Controllers/#examplepy-driver","text":"Below is an arbitrary example skeleton file of what an input driver should contain. For more concrete examples, look at the the mqtt or keyboard drivers. # Example input driver file from example_device import inputs def start_processing_input ( system_queue , demo_input_queue ): while True : events = inputs . events . get () for event in inputs . events : # Check for KEYDOWN event and pass into input queue if event . type == inputs . KEYDOWN : if event . key == ESCAPE : system_queue . put ( \"QUIT\" ) elif event . key == LEFT : demo_input_queue . put ( \"LEFT_P\" ) # Continues for all key presses... # check for KEYUP event and pass into input queue elif event . type == inputs . KEYUP : if event . key == LEFT : demo_input_queue . put ( \"LEFT_R\" ) elif event . key == UP : demo_input_queue . put ( \"UP_R\" ) # Continues for all key releases... # Check for QUIT event. elif event . type == QUIT : system_queue . put ( \"QUIT\" ) inputs . update ( events ) yield","title":"example.py Driver"},{"location":"Tutorials/Adding%20Input%20Controllers/#input-values","text":"","title":"Input Values"},{"location":"Tutorials/Adding%20Input%20Controllers/#generally-supported-input-values","text":"For an input controller to be compatible with all of the demos in the SSS system, the following input messages need to be handled: Value Description LEFT_P Left arrow pressed LEFT_R Left arrow released RIGHT_P Right arrow pressed RIGHT_P Right arrow released UP_P Up arrow pressed UP_R Up arrow released DOWN_P Down arrow pressed DOWN_R Down arrow released START_P Start button pressed START_R Start button released SEL_P Select button pressed SEL_R Select button released PRI_P Primary action button pressed PRI_R Primary action button released SEC_P Secondary action button pressed SEC_R Secondary action button released","title":"Generally supported input values"},{"location":"Tutorials/Adding%20Input%20Controllers/#demo-specific-input-values","text":"As of the current version of the SSS, there is no system-wide mechanism for handling demo-specific input. However, the assumption could be made that if only the specific controller and demo could understand the type of messages sent on the demo_input_queue and therefore this would not affect normal operation. Yet, this is untested behavior and is done at the risk of that specific input driver's authors/users.","title":"Demo specific input values"},{"location":"Tutorials/Adding%20Output%20Broadcasters/","text":"Adding Output Broadcasters One of the central ideas of the SSS is that any demo can transmit any type of output and as long as it is formatted correctly. Handling output from the SSS is not particularly difficult to do, but requires: 1. The correct initialization of the output device/service in __init__.py in the broadcasters module 2. The actual driver file which contains the logic to handle demo output by reading it in from the correct system queue (this will be it's own separate python file in the broadcasters directory). broadcasters module Much like the demos module which contains all of the games and demos the SSS runs, the broadcasters module is the central location where all of the output devices/services receive information from the demo's output_queue and relay that to the appropriate broadcasters. Just like a normal Python module, all of the initialization for this module takes place in the __init__.py . In the broadcasters module, the __init__.py is where all the broadcasting services are initialized, checked for exceptions, and process the information from the demos' output_queue . Initializing the output broadcaster In the __init__.py file, there is only one function: start_outputs(system_queue, demo_output_queue) which initializes all broadcasters and attaches them to the system_queue and the demo_output_queue . The beginning of this function is where we create a queue that will feed into output device. This is where the output of the demo_output_queue will eventually go. We then initialize the runner for our output device/service by declaring a variable and assigning it to the return value of our output driver's start_processing_output() function. In some cases, the initialization status of a broadcaster may be provided by a different function. Make sure you wrap the runner declaration inside of a try/execpt statement so if it fails, the entire SSS won't crash. In the case that the initialization runs into an exception, be sure to assign the runner to None . try : from . import example # This imports the actual output driver example_q = Queue () example_runner = example . start_processing_output ( system_queue , example_q ) except Exception as e : example_runner = None Polling from demo_output_queue At the bottom of start_outputs is an infinite loop which extracts the current values on the demo_output_queue and passes them to available broadcaster runners. To ensure that your broadcaster receives its outputs from the output queue for every tick of the program, make sure next() is called on the runner: # Loops through every available output message in the output queue for payload in utils . get_all_from_queue ( demo_output_queue ): # If broadcaster is successfully initialized, the output will go to the service/device's queue and into the driver if example_runner : example_q . put ( payload ) next ( example_runner ) The result The following is a simplified result of what the __init__.py file should look like after having set up our example output. from queue import Queue from loguru import logger from . import utils def start_outputs ( system_queue , demo_output_queue ): try : logger . info ( \"Loading example output...\" ) from . import example example_q = Queue () example_runner = example . start_processing_output ( system_queue , example_q ) logger . info ( \"...done\" ) except Exception as e : example_runner = None logger . warning ( e ) logger . warning ( \"Reason for broadcaster initialization failure will go here.\" ) logger . warning ( \"Program will continue to run without this output.\" ) # More broadcasters are declared and initialized here while True : for payload in utils . get_all_from_queue ( demo_output_queue ): if example_runner : example_q . put ( payload ) next ( example_runner ) # More output runners are `ticked` through here yield Output Driver File The contents of your output driver file varies widely based on the device or service's method of receiving input. The only requirement for each output driver file is a start_processing_output(system_queue, driver_q) function which should contain a generator that will read demo output values from the queue created for the driver before each yield . Depending on how your broadcasting service/device API works, you should return None from start_processing_output , throw an exception, or have a distinct function that checks initializability altogether in the case that it cannot start correctly. example.py Driver Below is an arbitrary example skeleton file of what an output driver could look like. For a more concrete example, look at the the mqtt driver. # Example output driver file from example_device import process_data from . import utils def start_processing_output ( system_queue , example_q ): while True : for item in utils . get_all_from_queue ( example_q ): process_data ( item ) yield Output Values Unlike demo_input_queue values, there are no set of universally supported output types for the SSS. It is understood that each type of output that gets put on the demo_output_queue will vary widely depending on that demo's targeted broadcaster and purpose. However, it is recommended that info that is sent on the output queue be formatted in JSON.","title":"Adding Output Broadcasters"},{"location":"Tutorials/Adding%20Output%20Broadcasters/#adding-output-broadcasters","text":"One of the central ideas of the SSS is that any demo can transmit any type of output and as long as it is formatted correctly. Handling output from the SSS is not particularly difficult to do, but requires: 1. The correct initialization of the output device/service in __init__.py in the broadcasters module 2. The actual driver file which contains the logic to handle demo output by reading it in from the correct system queue (this will be it's own separate python file in the broadcasters directory).","title":"Adding Output Broadcasters"},{"location":"Tutorials/Adding%20Output%20Broadcasters/#broadcasters-module","text":"Much like the demos module which contains all of the games and demos the SSS runs, the broadcasters module is the central location where all of the output devices/services receive information from the demo's output_queue and relay that to the appropriate broadcasters. Just like a normal Python module, all of the initialization for this module takes place in the __init__.py . In the broadcasters module, the __init__.py is where all the broadcasting services are initialized, checked for exceptions, and process the information from the demos' output_queue .","title":"broadcasters module"},{"location":"Tutorials/Adding%20Output%20Broadcasters/#initializing-the-output-broadcaster","text":"In the __init__.py file, there is only one function: start_outputs(system_queue, demo_output_queue) which initializes all broadcasters and attaches them to the system_queue and the demo_output_queue . The beginning of this function is where we create a queue that will feed into output device. This is where the output of the demo_output_queue will eventually go. We then initialize the runner for our output device/service by declaring a variable and assigning it to the return value of our output driver's start_processing_output() function. In some cases, the initialization status of a broadcaster may be provided by a different function. Make sure you wrap the runner declaration inside of a try/execpt statement so if it fails, the entire SSS won't crash. In the case that the initialization runs into an exception, be sure to assign the runner to None . try : from . import example # This imports the actual output driver example_q = Queue () example_runner = example . start_processing_output ( system_queue , example_q ) except Exception as e : example_runner = None","title":"Initializing the output broadcaster"},{"location":"Tutorials/Adding%20Output%20Broadcasters/#polling-from-demo_output_queue","text":"At the bottom of start_outputs is an infinite loop which extracts the current values on the demo_output_queue and passes them to available broadcaster runners. To ensure that your broadcaster receives its outputs from the output queue for every tick of the program, make sure next() is called on the runner: # Loops through every available output message in the output queue for payload in utils . get_all_from_queue ( demo_output_queue ): # If broadcaster is successfully initialized, the output will go to the service/device's queue and into the driver if example_runner : example_q . put ( payload ) next ( example_runner )","title":"Polling from demo_output_queue"},{"location":"Tutorials/Adding%20Output%20Broadcasters/#the-result","text":"The following is a simplified result of what the __init__.py file should look like after having set up our example output. from queue import Queue from loguru import logger from . import utils def start_outputs ( system_queue , demo_output_queue ): try : logger . info ( \"Loading example output...\" ) from . import example example_q = Queue () example_runner = example . start_processing_output ( system_queue , example_q ) logger . info ( \"...done\" ) except Exception as e : example_runner = None logger . warning ( e ) logger . warning ( \"Reason for broadcaster initialization failure will go here.\" ) logger . warning ( \"Program will continue to run without this output.\" ) # More broadcasters are declared and initialized here while True : for payload in utils . get_all_from_queue ( demo_output_queue ): if example_runner : example_q . put ( payload ) next ( example_runner ) # More output runners are `ticked` through here yield","title":"The result"},{"location":"Tutorials/Adding%20Output%20Broadcasters/#output-driver-file","text":"The contents of your output driver file varies widely based on the device or service's method of receiving input. The only requirement for each output driver file is a start_processing_output(system_queue, driver_q) function which should contain a generator that will read demo output values from the queue created for the driver before each yield . Depending on how your broadcasting service/device API works, you should return None from start_processing_output , throw an exception, or have a distinct function that checks initializability altogether in the case that it cannot start correctly.","title":"Output Driver File"},{"location":"Tutorials/Adding%20Output%20Broadcasters/#examplepy-driver","text":"Below is an arbitrary example skeleton file of what an output driver could look like. For a more concrete example, look at the the mqtt driver. # Example output driver file from example_device import process_data from . import utils def start_processing_output ( system_queue , example_q ): while True : for item in utils . get_all_from_queue ( example_q ): process_data ( item ) yield","title":"example.py Driver"},{"location":"Tutorials/Adding%20Output%20Broadcasters/#output-values","text":"Unlike demo_input_queue values, there are no set of universally supported output types for the SSS. It is understood that each type of output that gets put on the demo_output_queue will vary widely depending on that demo's targeted broadcaster and purpose. However, it is recommended that info that is sent on the output queue be formatted in JSON.","title":"Output Values"},{"location":"Tutorials/Creating%20a%20demo/","text":"Creating a demo At its core, using the SSS is meant to be a learning experience. Anyone who wants to know more about computer engineering and the Internet of Things can go through the demos and learn quite a bit by experiencing the end result. However, the SSS is also designed to be an educational tool for designers. Anyone with the desire can make a demo themselves without needing to understand the entire system! In this article, we will discuss the template for making one of these demos by looking at the template\u2019s basic structure and its required subcomponents. Template Format All of the demos for the SSS are located in the demos folder in the seven_segment_sign repo that you clone from GitHub. If you take a look at the contents of demos , you\u2019ll notice that each demo has its own folder with a main.py file inside of it: demos \u251c\u2500\u2500 breakout \u2502 \u251c\u2500\u2500 high_score.txt \u2502 \u2514\u2500\u2500 main.py \u251c\u2500\u2500 breakout_ai \u2502 \u2514\u2500\u2500 main.py \u251c\u2500\u2500 checkerboard \u2502 \u2514\u2500\u2500 main.py .... Notice that all of the folder names are lowercase and that all of the programs are named main.py . If you don\u2019t follow this convention, the system won\u2019t see your demo and it will fail to load when you run the program. But what goes inside of your main.py is what really counts. The following format must be observed for your demo to run correctly. If you want to use this example as a boilerplate to get you started, you can always copy it from demos/template/main.py . class Template : \"\"\"This is a boilerplate class for creating new demos/games for the SSS platform. It needs to include definitions for the following functions: init, run, stop. The init function needs to at least have the things shown below. Frame rate is in frames per second and demo time is in seconds. Demo time should be None if it is a game. The run function yields a generator. This generator will be called a specified frame rate, this controls what is being pushed to the screen. The stop function is called when the demo/game is being exited by the upper SSS software. It should reset the state for the game\"\"\" # User input is passed through input_queue # Game output is passed through output_queue # Screen updates are done through the screen object def __init__ ( self , input_queue , output_queue , screen ): # Provide the framerate in frames/seconds and the amount of time of the demo in seconds self . frame_rate = 10 self . demo_time = 300 # None for a game self . input_queue = input_queue self . output_queue = output_queue self . screen = screen # init demo/game specific variables here def run ( self ): # Create generator here while True : self . screen . draw_text ( self . screen . x_width // 2 - 5 , self . screen . y_height // 2 - 4 , \"HELLO THERE\" , push = True ) yield def stop ( self ): # Reset the state of the demo if needed, else leave blank pass When creating your class object, name sure that the first letter of its name is capitalized. If you have a demo with two words (i.e. breakout_ai ) make sure you capitalize the first letter of every word (i.e. Breakout_Ai ). Failure to do this will cause your demo to not load or execute properly into the SSS system. You\u2019ll also notice that apart from the normal Python __init__() method for a class, there is also a run() , stop() , and get_input_buff() . Implementing these functions is crucial to making sure that your demo will execute correctly at runtime. An explanation of what each one does is included below. __init__() This function allows you to set up some initial values for your demo. For example, if you were creating a game and wanted to include the initial amount of lives or the amount of ammo in a shooter, __init__() is the perfect place to set that up! Apart demo-specific variables that could be initialized, there are also a few SSS specific variables which must also be initialized which will affect how your demo runs and interacts with the rest of the system. frame_rate This variable determines how fast your demo runs (i.e how many frames are rendered in a second). If your game is intended to have a buttery experience higher values will be more suited to your needs. NOTE: setting the frame_rate too high can result in too quick of a game on the simulator or undefined behavior on the actual SSS due to hardware limitations. demo_time If you are creating a non-interactive demo (i.e. a shape bouncing around the screen or some other concept that does not require input), you will need to set a demo_time. This value will determine how long your demo will run for when the SSS is in kiosk/screensaver mode (i.e. cycling through demos when no one is actively using it). If you are planning on developing an interactive demo/game, set this value to None . input_queue If you are creating a demo which requires active user input, you will need to keep track of the values are are coming in through the input queue. Regardless of what controller is connected to the SSS, the supported inputs are: Value Description LEFT_P Left arrow pressed LEFT_R Left arrow released RIGHT_P Right arrow pressed RIGHT_R Right arrow released UP_P Up arrow pressed UP_R Up arrow released DOWN_P Down arrow pressed DOWN_R Down arrow released START_P Start button pressed START_R Start button released SEL_P Select button pressed SEL_R Select button released PRI_P Primary action button pressed PRI_R Primary action button released SEC_P Secondary action button pressed SEC_R Secondary action button released By setting self.input_queue = input_queue you link the input_queue for your demo to the system\u2019s input buffer. All input information can be retrieved directly through this object or by using the get_input_buff() function as explained below. NOTE: This object is a Python Queue object. Any functions found here can be used on this object. output_queue If your demo needs to communicate information that will not be seen on the screen back to the user (i.e. a score or number of lives), this can be accomplished by using the output_queue. You can link your demo\u2019s output_queue to the system output_queue by using self.output_queue = output_queue . At the current moment there are a limited amount of topics that you can send output through: Value Description SCORE Sets the score of a game. LIVES Keeps track of the amount lives of a player To send data through one of these channels, you will put the name of the topic and the value you wish to send: self . output_queue . put ( \"SCORE \" + str ( self . score )) NOTE: This object is a Python Queue object. Any functions found here can be used on this object. screen This object controls what will be drawn on the screen. Any functions as described in this API doc will work on this screen object. The demo screen is connected to the SSS system screen as follows: self . screen = screen run() This function is what causes your actual program to run. Everything inside of this demo will be executed at runtime. Notice that in our boilerplate we surround the contents of this function with a while True loop ending with a yield . This special organization will cause whatever is inside the loop to be repeated until the system indicates that it is time for your demo to stop. By placing a yield keyword at the end of the loop, this converts the function from a blocking function to a non-blocking function (for the purposes of the system). If yield is not provided at the end of a frame rendering, the program will have no way to release control back to the SSS to actually draw anything or process any inputs and outputs that the demo. For a simple example of how a demo works with this non-blocking functionality, take a look at the template demo. For more complex examples, demos such as game_of_life , snake , or breakout which include multiple yield s for multiple cases. stop() Code in this function will be exited right as soon as your demo is ended by the SSS or user. If you need to reset state or do any sort of cleanup, that code belongs here. If there is nothing fancy like that in your demo, no worries! Just leave a pass and be on your merry way. Handling Input in Your Demo Most games on the SSS are pretty simple and are only meant to handle one keypress at a time. However, if you are feeling ambitious and want to keep track of multiple keypresses at a time (i.e. holding up and left to jump diagonally), this function will help you catch that by returning all keypresses waiting in the queue as a list. Below is a snippet from breakout which illustrates this functionality: # Include this at the top of your demo from demos.utils import get_all_from_queue # Put this part in your while True loop for keypress in get_all_from_queue ( self . input_queue ): if keypress == \"LEFT_P\" : # Some action pass if keypress == \"LEFT_R\" : # Some action pass if keypress == \"RIGHT_P\" : # Some action pass if keypress == \"RIGHT_R\" : # Some action pass Conclusion By following the template format, you learn about and are accountable for most of the key components of a demo! If you are still feeling overwhelmed and don\u2019t know where to start in your demo creation journey, take a look at some of the existing ones and try to modify them bit by bit, taking note of what changes you caused. If there are any clarifications that need to be made, please feel free to reach out by opening an issue on the GitHub repo or taking a look at how to get support so we can help you and also update our docs. We\u2019re excited to see what you create!","title":"Creating a demo"},{"location":"Tutorials/Creating%20a%20demo/#creating-a-demo","text":"At its core, using the SSS is meant to be a learning experience. Anyone who wants to know more about computer engineering and the Internet of Things can go through the demos and learn quite a bit by experiencing the end result. However, the SSS is also designed to be an educational tool for designers. Anyone with the desire can make a demo themselves without needing to understand the entire system! In this article, we will discuss the template for making one of these demos by looking at the template\u2019s basic structure and its required subcomponents.","title":"Creating a demo"},{"location":"Tutorials/Creating%20a%20demo/#template-format","text":"All of the demos for the SSS are located in the demos folder in the seven_segment_sign repo that you clone from GitHub. If you take a look at the contents of demos , you\u2019ll notice that each demo has its own folder with a main.py file inside of it: demos \u251c\u2500\u2500 breakout \u2502 \u251c\u2500\u2500 high_score.txt \u2502 \u2514\u2500\u2500 main.py \u251c\u2500\u2500 breakout_ai \u2502 \u2514\u2500\u2500 main.py \u251c\u2500\u2500 checkerboard \u2502 \u2514\u2500\u2500 main.py .... Notice that all of the folder names are lowercase and that all of the programs are named main.py . If you don\u2019t follow this convention, the system won\u2019t see your demo and it will fail to load when you run the program. But what goes inside of your main.py is what really counts. The following format must be observed for your demo to run correctly. If you want to use this example as a boilerplate to get you started, you can always copy it from demos/template/main.py . class Template : \"\"\"This is a boilerplate class for creating new demos/games for the SSS platform. It needs to include definitions for the following functions: init, run, stop. The init function needs to at least have the things shown below. Frame rate is in frames per second and demo time is in seconds. Demo time should be None if it is a game. The run function yields a generator. This generator will be called a specified frame rate, this controls what is being pushed to the screen. The stop function is called when the demo/game is being exited by the upper SSS software. It should reset the state for the game\"\"\" # User input is passed through input_queue # Game output is passed through output_queue # Screen updates are done through the screen object def __init__ ( self , input_queue , output_queue , screen ): # Provide the framerate in frames/seconds and the amount of time of the demo in seconds self . frame_rate = 10 self . demo_time = 300 # None for a game self . input_queue = input_queue self . output_queue = output_queue self . screen = screen # init demo/game specific variables here def run ( self ): # Create generator here while True : self . screen . draw_text ( self . screen . x_width // 2 - 5 , self . screen . y_height // 2 - 4 , \"HELLO THERE\" , push = True ) yield def stop ( self ): # Reset the state of the demo if needed, else leave blank pass When creating your class object, name sure that the first letter of its name is capitalized. If you have a demo with two words (i.e. breakout_ai ) make sure you capitalize the first letter of every word (i.e. Breakout_Ai ). Failure to do this will cause your demo to not load or execute properly into the SSS system. You\u2019ll also notice that apart from the normal Python __init__() method for a class, there is also a run() , stop() , and get_input_buff() . Implementing these functions is crucial to making sure that your demo will execute correctly at runtime. An explanation of what each one does is included below.","title":"Template Format"},{"location":"Tutorials/Creating%20a%20demo/#__init__","text":"This function allows you to set up some initial values for your demo. For example, if you were creating a game and wanted to include the initial amount of lives or the amount of ammo in a shooter, __init__() is the perfect place to set that up! Apart demo-specific variables that could be initialized, there are also a few SSS specific variables which must also be initialized which will affect how your demo runs and interacts with the rest of the system.","title":"__init__()"},{"location":"Tutorials/Creating%20a%20demo/#frame_rate","text":"This variable determines how fast your demo runs (i.e how many frames are rendered in a second). If your game is intended to have a buttery experience higher values will be more suited to your needs. NOTE: setting the frame_rate too high can result in too quick of a game on the simulator or undefined behavior on the actual SSS due to hardware limitations.","title":"frame_rate"},{"location":"Tutorials/Creating%20a%20demo/#demo_time","text":"If you are creating a non-interactive demo (i.e. a shape bouncing around the screen or some other concept that does not require input), you will need to set a demo_time. This value will determine how long your demo will run for when the SSS is in kiosk/screensaver mode (i.e. cycling through demos when no one is actively using it). If you are planning on developing an interactive demo/game, set this value to None .","title":"demo_time"},{"location":"Tutorials/Creating%20a%20demo/#input_queue","text":"If you are creating a demo which requires active user input, you will need to keep track of the values are are coming in through the input queue. Regardless of what controller is connected to the SSS, the supported inputs are: Value Description LEFT_P Left arrow pressed LEFT_R Left arrow released RIGHT_P Right arrow pressed RIGHT_R Right arrow released UP_P Up arrow pressed UP_R Up arrow released DOWN_P Down arrow pressed DOWN_R Down arrow released START_P Start button pressed START_R Start button released SEL_P Select button pressed SEL_R Select button released PRI_P Primary action button pressed PRI_R Primary action button released SEC_P Secondary action button pressed SEC_R Secondary action button released By setting self.input_queue = input_queue you link the input_queue for your demo to the system\u2019s input buffer. All input information can be retrieved directly through this object or by using the get_input_buff() function as explained below. NOTE: This object is a Python Queue object. Any functions found here can be used on this object.","title":"input_queue"},{"location":"Tutorials/Creating%20a%20demo/#output_queue","text":"If your demo needs to communicate information that will not be seen on the screen back to the user (i.e. a score or number of lives), this can be accomplished by using the output_queue. You can link your demo\u2019s output_queue to the system output_queue by using self.output_queue = output_queue . At the current moment there are a limited amount of topics that you can send output through: Value Description SCORE Sets the score of a game. LIVES Keeps track of the amount lives of a player To send data through one of these channels, you will put the name of the topic and the value you wish to send: self . output_queue . put ( \"SCORE \" + str ( self . score )) NOTE: This object is a Python Queue object. Any functions found here can be used on this object.","title":"output_queue"},{"location":"Tutorials/Creating%20a%20demo/#screen","text":"This object controls what will be drawn on the screen. Any functions as described in this API doc will work on this screen object. The demo screen is connected to the SSS system screen as follows: self . screen = screen","title":"screen"},{"location":"Tutorials/Creating%20a%20demo/#run","text":"This function is what causes your actual program to run. Everything inside of this demo will be executed at runtime. Notice that in our boilerplate we surround the contents of this function with a while True loop ending with a yield . This special organization will cause whatever is inside the loop to be repeated until the system indicates that it is time for your demo to stop. By placing a yield keyword at the end of the loop, this converts the function from a blocking function to a non-blocking function (for the purposes of the system). If yield is not provided at the end of a frame rendering, the program will have no way to release control back to the SSS to actually draw anything or process any inputs and outputs that the demo. For a simple example of how a demo works with this non-blocking functionality, take a look at the template demo. For more complex examples, demos such as game_of_life , snake , or breakout which include multiple yield s for multiple cases.","title":"run()"},{"location":"Tutorials/Creating%20a%20demo/#stop","text":"Code in this function will be exited right as soon as your demo is ended by the SSS or user. If you need to reset state or do any sort of cleanup, that code belongs here. If there is nothing fancy like that in your demo, no worries! Just leave a pass and be on your merry way.","title":"stop()"},{"location":"Tutorials/Creating%20a%20demo/#handling-input-in-your-demo","text":"Most games on the SSS are pretty simple and are only meant to handle one keypress at a time. However, if you are feeling ambitious and want to keep track of multiple keypresses at a time (i.e. holding up and left to jump diagonally), this function will help you catch that by returning all keypresses waiting in the queue as a list. Below is a snippet from breakout which illustrates this functionality: # Include this at the top of your demo from demos.utils import get_all_from_queue # Put this part in your while True loop for keypress in get_all_from_queue ( self . input_queue ): if keypress == \"LEFT_P\" : # Some action pass if keypress == \"LEFT_R\" : # Some action pass if keypress == \"RIGHT_P\" : # Some action pass if keypress == \"RIGHT_R\" : # Some action pass","title":"Handling Input in Your Demo"},{"location":"Tutorials/Creating%20a%20demo/#conclusion","text":"By following the template format, you learn about and are accountable for most of the key components of a demo! If you are still feeling overwhelmed and don\u2019t know where to start in your demo creation journey, take a look at some of the existing ones and try to modify them bit by bit, taking note of what changes you caused. If there are any clarifications that need to be made, please feel free to reach out by opening an issue on the GitHub repo or taking a look at how to get support so we can help you and also update our docs. We\u2019re excited to see what you create!","title":"Conclusion"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/","text":"Game Display Many of the following functions have parameters called combine and push. Push is inherently set to False. If it is set to True then all of the recent game display function calls will be written to the screen. Combine is inherently set to True. Each of the the individual seven segment digits are broken up into two separate digits. When writing to one of the pixels of a digit, combine states that you want to keep what is in the other pixel of the digit. When set to false it will erase whatever is on the other side of the digit. This is a quirk of making pixels out of seven segment digits. Many of the below functions also take an x and y parameters. These are self explanatory. They are the x, y coordinates of where you want to start to draw. The origin is on the top left of the screen. A game_display object has a x_width and y_height class member that can be accessed and encouraged to be used. init The init function has three parameters: board_objects, x_width, and y_height. The later two are easier to explain. The x_width and y_height are for how many pixels the display is across. A seven segment display digit is broken up into 1 pixel across and 2 pixels down, where the two pixels down share the middle line. Lets say you have 8 seven segment digits across you would put 8 for x_width and 2 for y_height. The last parameter is the board_objects. This parameter needs to be a 2d list of panel objects in the order they are on the sign. The hardware is broken up into 3 panels across and 4 panels down. Each panel has 16 columns and 6 rows of digits. An example of what would be passed into this is [[panel0, panel1, panel2],[panel3, panel4, panel5],[panel6, panel7, panel8],[panel9, panel10, panel11]]. For the physical hardware, the panel class is called SevenSegnment, which can be found under display/seven_seg.py. The simulator panel class is called Panel and is found under simulator/simulator.py. draw_pixel This function call is the simplest out of all of them. It will draw an individual pixel to the screen. A pixel is defined by the four sides of either the top or bottom of the individual digit.. The value parameters of this function determines which of those four sides is turned on. It is controlled by a nibble of data (4 bits). Pass a 1 for the bottom, 2 for the left, 4 for the top, 8 for the right, and any combination thereof. var a = false; var b = false; var c = false; var d = false; var canvas; var context; $(document).ready(function () { canvas = $(\"#canvas\")[0]; context = canvas.getContext(\"2d\"); regularpolygon(context, 0, false); regularpolygon(context, 2, false); regularpolygon(context, 1, false); regularpolygon(context, 3, false); }); function regularpolygon(ctx, pos, fill) { ctx.font = \"30px Arial\"; switch (pos) { case 0: c = fill; ctx.beginPath(); ctx.moveTo(75, 50); ctx.lineTo(175, 50); ctx.lineTo(200, 75); ctx.lineTo(175, 100); ctx.lineTo(75, 100); ctx.lineTo(50, 75); ctx.lineTo(75, 50); ctx.closePath(); if (fill == true) { ctx.fillStyle = '#f00'; ctx.fill(); ctx.fillStyle = '#fff'; } else { ctx.fillStyle = '#fff'; ctx.fill(); ctx.fillStyle = '#f00'; } context.fillText(\"c\", 115, 83); ctx.stroke(); break; case 1: b = fill; ctx.beginPath(); ctx.moveTo(45, 80); ctx.lineTo(70, 105); ctx.lineTo(60, 205); ctx.lineTo(35, 230); ctx.lineTo(10, 205); ctx.lineTo(20, 105); ctx.lineTo(45, 80); ctx.closePath(); if (fill == true) { ctx.fillStyle = '#f00'; ctx.fill(); ctx.fillStyle = '#fff'; } else { ctx.fillStyle = '#fff'; ctx.fill(); ctx.fillStyle = '#f00'; } context.fillText(\"b\", 30, 160); ctx.stroke(); break; case 2: a = fill; ctx.beginPath(); ctx.moveTo(65, 210); ctx.lineTo(165, 210); ctx.lineTo(190, 235); ctx.lineTo(165, 260); ctx.lineTo(65, 260); ctx.lineTo(40, 235); ctx.lineTo(65, 210); ctx.closePath(); if (fill == true) { ctx.fillStyle = '#f00'; ctx.fill(); ctx.fillStyle = '#fff'; } else { ctx.fillStyle = '#fff'; ctx.fill(); ctx.fillStyle = '#f00'; } context.fillText(\"a\", 105, 243); ctx.stroke(); break; case 3: d = fill; ctx.beginPath(); ctx.moveTo(205, 80); ctx.lineTo(230, 105); ctx.lineTo(220, 205); ctx.lineTo(195, 230); ctx.lineTo(170, 205); ctx.lineTo(180, 105); ctx.lineTo(205, 80); ctx.closePath(); if (fill == true) { ctx.fillStyle = '#f00'; ctx.fill(); ctx.fillStyle = '#fff'; } else { ctx.fillStyle = '#fff'; ctx.fill(); ctx.fillStyle = '#f00'; } context.fillText(\"d\", 190, 160); ctx.stroke(); break; } let val = 0; if (a) { val = val + 1 } if (b) { val = val + 2 } if (c) { val = val + 4 } if (d) { val = val + 8 } document.getElementById('hexval').textContent = \"0x\" + val.toString(16); } // function updatepixel(texval) // { // if(texval) // } OOPS.. Upgrade your Browser Use the buttons to configure the pixel! a b c d draw_hline This function simply draws a horizontal line on the screen. It starts at the given x and y value and goes the provided length. The top parameter is set to True by default meaning the horizontal line will be drawn on the top of the pixel. When set to false it will drawn on the bottom of the pixel. This function draws from the left to the right on the screen. draw_vline This function simply draws a vertical line on the screen. It starts at the given x and y value and goes the provide length. The left parameter is set to True by default meaning the vertical line will be drawn on the left side of the pixel. When set to false it will be drawn on the right of the pixel. This function draws from the top to the bottom on the screen. draw_shape_line This function is a can draw an arbitrary pixel design in a line. This line can be diagonal even. It has the additional end_x and end_y parameters. draw_text This function can draw a text string to the display. It can even split between two vertically aligned digits. It is hard to see what the text is at that point but it is a possibility. The display/symbols.py file provides a list of almost 90 different ASCII characters that can be drawn on the screen. Many of the characters are an approximation and may not look the way you are expecting it to look. Since this function can draw on split functions this function can not be called lower than the screen pixel height - 2. get_pixel This is a specialty function call that can return what is supposed to be displayed at a given x and y value push When you call many of the above functions it will not immediately write the graphic to the screen. It is put into a buffer to be processed all at once. The push function is the function that actually pushes the changes to the screen. It is more efficient to write to the screen in this manner. clear This function will clear the display buffer and the graphics on the screen. It is slow and many artifacts can be seen if it is called over and over. It generally should only be called when a game is starting or ending and the entire screen needs to be cleared off. These are the base functions that we felt were needed to do almost everything we needed for the demos. Feel free to add more functions. Make sure to thoroughly test it on many edge cases.","title":"Game Display"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/#game-display","text":"Many of the following functions have parameters called combine and push. Push is inherently set to False. If it is set to True then all of the recent game display function calls will be written to the screen. Combine is inherently set to True. Each of the the individual seven segment digits are broken up into two separate digits. When writing to one of the pixels of a digit, combine states that you want to keep what is in the other pixel of the digit. When set to false it will erase whatever is on the other side of the digit. This is a quirk of making pixels out of seven segment digits. Many of the below functions also take an x and y parameters. These are self explanatory. They are the x, y coordinates of where you want to start to draw. The origin is on the top left of the screen. A game_display object has a x_width and y_height class member that can be accessed and encouraged to be used.","title":"Game Display"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/#init","text":"The init function has three parameters: board_objects, x_width, and y_height. The later two are easier to explain. The x_width and y_height are for how many pixels the display is across. A seven segment display digit is broken up into 1 pixel across and 2 pixels down, where the two pixels down share the middle line. Lets say you have 8 seven segment digits across you would put 8 for x_width and 2 for y_height. The last parameter is the board_objects. This parameter needs to be a 2d list of panel objects in the order they are on the sign. The hardware is broken up into 3 panels across and 4 panels down. Each panel has 16 columns and 6 rows of digits. An example of what would be passed into this is [[panel0, panel1, panel2],[panel3, panel4, panel5],[panel6, panel7, panel8],[panel9, panel10, panel11]]. For the physical hardware, the panel class is called SevenSegnment, which can be found under display/seven_seg.py. The simulator panel class is called Panel and is found under simulator/simulator.py.","title":"init"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/#draw_pixel","text":"This function call is the simplest out of all of them. It will draw an individual pixel to the screen. A pixel is defined by the four sides of either the top or bottom of the individual digit.. The value parameters of this function determines which of those four sides is turned on. It is controlled by a nibble of data (4 bits). Pass a 1 for the bottom, 2 for the left, 4 for the top, 8 for the right, and any combination thereof. var a = false; var b = false; var c = false; var d = false; var canvas; var context; $(document).ready(function () { canvas = $(\"#canvas\")[0]; context = canvas.getContext(\"2d\"); regularpolygon(context, 0, false); regularpolygon(context, 2, false); regularpolygon(context, 1, false); regularpolygon(context, 3, false); }); function regularpolygon(ctx, pos, fill) { ctx.font = \"30px Arial\"; switch (pos) { case 0: c = fill; ctx.beginPath(); ctx.moveTo(75, 50); ctx.lineTo(175, 50); ctx.lineTo(200, 75); ctx.lineTo(175, 100); ctx.lineTo(75, 100); ctx.lineTo(50, 75); ctx.lineTo(75, 50); ctx.closePath(); if (fill == true) { ctx.fillStyle = '#f00'; ctx.fill(); ctx.fillStyle = '#fff'; } else { ctx.fillStyle = '#fff'; ctx.fill(); ctx.fillStyle = '#f00'; } context.fillText(\"c\", 115, 83); ctx.stroke(); break; case 1: b = fill; ctx.beginPath(); ctx.moveTo(45, 80); ctx.lineTo(70, 105); ctx.lineTo(60, 205); ctx.lineTo(35, 230); ctx.lineTo(10, 205); ctx.lineTo(20, 105); ctx.lineTo(45, 80); ctx.closePath(); if (fill == true) { ctx.fillStyle = '#f00'; ctx.fill(); ctx.fillStyle = '#fff'; } else { ctx.fillStyle = '#fff'; ctx.fill(); ctx.fillStyle = '#f00'; } context.fillText(\"b\", 30, 160); ctx.stroke(); break; case 2: a = fill; ctx.beginPath(); ctx.moveTo(65, 210); ctx.lineTo(165, 210); ctx.lineTo(190, 235); ctx.lineTo(165, 260); ctx.lineTo(65, 260); ctx.lineTo(40, 235); ctx.lineTo(65, 210); ctx.closePath(); if (fill == true) { ctx.fillStyle = '#f00'; ctx.fill(); ctx.fillStyle = '#fff'; } else { ctx.fillStyle = '#fff'; ctx.fill(); ctx.fillStyle = '#f00'; } context.fillText(\"a\", 105, 243); ctx.stroke(); break; case 3: d = fill; ctx.beginPath(); ctx.moveTo(205, 80); ctx.lineTo(230, 105); ctx.lineTo(220, 205); ctx.lineTo(195, 230); ctx.lineTo(170, 205); ctx.lineTo(180, 105); ctx.lineTo(205, 80); ctx.closePath(); if (fill == true) { ctx.fillStyle = '#f00'; ctx.fill(); ctx.fillStyle = '#fff'; } else { ctx.fillStyle = '#fff'; ctx.fill(); ctx.fillStyle = '#f00'; } context.fillText(\"d\", 190, 160); ctx.stroke(); break; } let val = 0; if (a) { val = val + 1 } if (b) { val = val + 2 } if (c) { val = val + 4 } if (d) { val = val + 8 } document.getElementById('hexval').textContent = \"0x\" + val.toString(16); } // function updatepixel(texval) // { // if(texval) // } OOPS.. Upgrade your Browser","title":"draw_pixel"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/#draw_hline","text":"This function simply draws a horizontal line on the screen. It starts at the given x and y value and goes the provided length. The top parameter is set to True by default meaning the horizontal line will be drawn on the top of the pixel. When set to false it will drawn on the bottom of the pixel. This function draws from the left to the right on the screen.","title":"draw_hline"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/#draw_vline","text":"This function simply draws a vertical line on the screen. It starts at the given x and y value and goes the provide length. The left parameter is set to True by default meaning the vertical line will be drawn on the left side of the pixel. When set to false it will be drawn on the right of the pixel. This function draws from the top to the bottom on the screen.","title":"draw_vline"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/#draw_shape_line","text":"This function is a can draw an arbitrary pixel design in a line. This line can be diagonal even. It has the additional end_x and end_y parameters.","title":"draw_shape_line"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/#draw_text","text":"This function can draw a text string to the display. It can even split between two vertically aligned digits. It is hard to see what the text is at that point but it is a possibility. The display/symbols.py file provides a list of almost 90 different ASCII characters that can be drawn on the screen. Many of the characters are an approximation and may not look the way you are expecting it to look. Since this function can draw on split functions this function can not be called lower than the screen pixel height - 2.","title":"draw_text"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/#get_pixel","text":"This is a specialty function call that can return what is supposed to be displayed at a given x and y value","title":"get_pixel"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/#push","text":"When you call many of the above functions it will not immediately write the graphic to the screen. It is put into a buffer to be processed all at once. The push function is the function that actually pushes the changes to the screen. It is more efficient to write to the screen in this manner.","title":"push"},{"location":"Tutorials/Game%20Display%20%28Graphics%20functions%29/#clear","text":"This function will clear the display buffer and the graphics on the screen. It is slow and many artifacts can be seen if it is called over and over. It generally should only be called when a game is starting or ending and the entire screen needs to be cleared off. These are the base functions that we felt were needed to do almost everything we needed for the demos. Feel free to add more functions. Make sure to thoroughly test it on many edge cases.","title":"clear"}]}